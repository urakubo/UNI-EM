{"version":3,"file":"1.bundle.js","sources":["webpack:///./js/APP.js","webpack:///./js/ControlAnnotator.js","webpack:///./js/HandleBasement.js","webpack:///./js/HandleMarkers.js","webpack:///./js/HandleSkeletons.js","webpack:///./js/HandleSpheres.js","webpack:///./js/HandleSurfaces.js","webpack:///./js/MarkerTable.js","webpack:///./js/PaintTable.js","webpack:///./js/SurfaceTable.js","webpack:///./js/SyncPaint.js","webpack:///./js/csv.js","webpack:///./js/init.js","webpack:///./js/three_annotator/geometryState.js","webpack:///./js/three_annotator/index.js","webpack:///./js/util.js","webpack:///util (ignored)","webpack:///util (ignored)?9874","webpack:///buffer (ignored)","webpack:///crypto (ignored)","webpack:///ws (ignored)"],"sourcesContent":["export const APP = {};\nwindow.APP = APP;","import { APP } from \"./APP\";\n\n//\n\n// Executed when the window size is changed.\nwindow.addEventListener('resize', function() {\n\t// サイズを取得\n\tconst width = window.innerWidth;\n\tconst height = window.innerHeight;\n\n\t// カメラのアスペクト比を正す\n\tAPP.camera.aspect = (width * xratio) / (height * yratio);\n\tAPP.camera.updateProjectionMatrix();\n\n\t// レンダラーのサイズを調整する\n\tAPP.renderer.setPixelRatio(window.devicePixelRatio);\n\tAPP.renderer.setSize(width * xratio, height * yratio);\n\t}, false );\n\n// Mode\nwindow.ChangeMode = function (mode) {\n\tswitch (mode) {\n\t\tcase \"view\":\n//\t\t\tconsole.log(\"view\")\n\t\t\tAPP.MarkerMode   = 0;\n\t\t\tAPP.SkeletonMode = 0;\n\t\t\tAPP.SphereMode   = 0;\n\t\t\tAPP.cursor.visible = false;\n\t\t\tswitchAnnotation(0);\n\t\t\tAPP.changeSurfaceObjectOpacity(-1);\n\t\t\tAPP.removeSkeletons();\n\t\t\tAPP.removeSpheres();\n\t\t\tbreak;\n\t\tcase \"point\":\n//\t\t\tconsole.log(\"point\")\n\t\t\tAPP.MarkerMode   = 1;\n\t\t\tAPP.SkeletonMode = 0;\n\t\t\tAPP.SphereMode   = 0;\n\t\t\tAPP.cursor.visible = false;\n\t\t\tswitchAnnotation(0);\n\t\t\tAPP.changeSurfaceObjectOpacity(-1);\n\t\t\tAPP.removeSkeletons();\n\t\t\tAPP.removeSpheres();\n\t\t\tbreak;\n\t\tcase \"paint\":\n//\t\t\tconsole.log(\"paint\")\n\t\t\tAPP.MarkerMode   = 0;\n\t\t\tAPP.SkeletonMode = 0;\n\t\t\tAPP.SphereMode   = 0;\n\t\t\tAPP.cursor.visible = true;\n\t\t\tswitchAnnotation(1);\n\t\t\tAPP.changeSurfaceObjectOpacity(-1);\n\t\t\tAPP.removeSkeletons();\n\t\t\tAPP.removeSpheres();\n\t\t\tbreak;\n\t\tcase \"skeleton\":\n//\t\t\tconsole.log(\"skeleton\")\n\t\t\tAPP.MarkerMode   = 0;\n\t\t\tAPP.SkeletonMode = 1;\n\t\t\tAPP.SphereMode   = 0;\n\t\t\tAPP.cursor.visible = false;\n\t\t\tswitchAnnotation(0);\n\t\t\tAPP.changeSurfaceObjectOpacity(0);\n\t\t\tAPP.addSkeletons();\n\t\t\tAPP.removeSpheres();\n\t\t\tbreak;\n\t\tcase \"sphere\":\n//\t\t\tconsole.log(\"shpere\")\n\t\t\tAPP.MarkerMode   = 0;\n\t\t\tAPP.SkeletonMode = 0;\n\t\t\tAPP.SphereMode   = 1;\n\t\t\tAPP.cursor.visible = false;\n\t\t\tswitchAnnotation(0);\n\t\t\tAPP.changeSurfaceObjectOpacity(-2);\n\t\t\tAPP.removeSkeletons();\n\t\t\tAPP.addSpheres();\n\t\t\tbreak;\t\t\n\t\tdefault:\n    \t\tconsole.log(`Error. Mode ${mode} cannot be interpreted.`);\n\t\t}\n\t}\n//\n// app/index.jsで使っている\n//\nwindow.MarkerOffOn = function (ischecked) {\n\t\tif( ischecked == true ) {\n      \t\tAPP.MarkerOffOn = 1;\n   \t\t\t}\n\t\telse {\n\t\t\tAPP.MarkerOffOn = 0;\n\t\t\t}\n      }\n\n\nwindow.SaveImage = function (ischecked) {\n\tlet canvas = document.getElementById(\"myCanvas\").querySelector('canvas');\n\n\tlet link = document.createElement(\"a\");\n\tlink.href = canvas.toDataURL(\"image/png\");\n\tlink.download = \"Screenshot.png\";\n\tlink.click();\n\t}\n\n\n//\n// View\n//\nwindow.BackgroundWhiteBlack = function (ischecked) {\n\t\tif( ischecked == true ) {\n\t\t\tAPP.scene.background = new THREE.Color( 0x000000 );\n\t\t\tAPP.BackGroundColor = 'Black';\n\t\t\tsetBoundingBoxColor( 0xffffff );\n   \t\t\t}\n\t\telse {\n\t\t\tAPP.scene.background = new THREE.Color( 0xffffff );\n      \t\tAPP.BackGroundColor = 'White';\n      \t\tsetBoundingBoxColor( 0x000000 );\n\t\t\t}\n      }\nwindow.DirLight = function (isnum) {\n\t\tAPP.directionalLight.intensity = isnum / 100;\n      }\n\nwindow.AmbLight = function (isnum) {\n\t\tAPP.ambientLight.intensity = isnum / 100;\n      }\n\nwindow.CenterXY = function () {\n\tAPP.camera.up.set(0,1,0);\n\tAPP.camera.position.set( APP.BoundingboxX/2.0, APP.BoundingboxY/2.0, APP.BoundingboxMax*3.0);\n\tAPP.camera.lookAt(APP.BoundingboxZ/2.0, APP.BoundingboxY/2.0, APP.BoundingboxX/2.0);\n\tAPP.controls.target.set( APP.BoundingboxX/2.0 , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\n\t// APP.renderer.render(APP.scene, APP.camera);\n\t}\n\nwindow.CenterYZ = function () {\n\tAPP.camera.up.set(0,0,1);\n\tAPP.camera.position.set( APP.BoundingboxMax*3.0  , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\n\tAPP.camera.lookAt(APP.BoundingboxZ/2.0, APP.BoundingboxY/2.0, APP.BoundingboxX/2.0);\n\tAPP.controls.target.set( APP.BoundingboxX/2.0 , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\n\t// APP.renderer.render(APP.scene, APP.camera);\n\t}\n\nwindow.CenterZX = function () {\n\tAPP.camera.up.set(1,0,0);\n\tAPP.camera.position.set( APP.BoundingboxX/2.0, APP.BoundingboxMax*3.0, APP.BoundingboxZ/2.0);\n\tAPP.camera.lookAt(APP.BoundingboxZ/2.0, APP.BoundingboxY/2.0, APP.BoundingboxX/2.0);\n\tAPP.controls.target.set( APP.BoundingboxX/2.0 , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\n\t// APP.renderer.render(APP.scene, APP.camera);\n\t}\n\n\nwindow.DirLightX = function (ischecked) {\n\tif( ischecked == true ) {\n  \t\tAPP.directionalLight.position.x = APP.BoundingboxX/2.0+APP.BoundingboxMax;\n\t\t}\n\telse {\n\t\tAPP.directionalLight.position.x = APP.BoundingboxX/2.0-APP.BoundingboxMax;\n\t\t}\n\t// APP.renderer.render(APP.scene, APP.camera);\n\t}\n\nwindow.DirLightY = function (ischecked) {\n\tif( ischecked == true ) {\n\t\tAPP.directionalLight.position.y = APP.BoundingboxY/2.0+APP.BoundingboxMax;\n\t\t}\n\telse {\n\t\tAPP.directionalLight.position.y = APP.BoundingboxY/2.0-APP.BoundingboxMax;\n\t\t}\n\t}\n\nwindow.DirLightZ = function (ischecked) {\n\tif( ischecked == true ) {\n\t\tAPP.directionalLight.position.z = APP.BoundingboxZ/2.0+APP.BoundingboxMax;\n\t\t}\n\telse {\n\t\tAPP.directionalLight.position.z = APP.BoundingboxZ/2.0-APP.BoundingboxMax;\n\t\t}\n\t}\nwindow.FrameOffOn =  function (ischecked) {\n\t\tif( ischecked == true ) {\n      \t\taddBoundingBox();\n   \t\t\t}\n\t\telse {\n\t\t\tremoveBoundingBox();\n\t\t\t}\n      }\n\n\n// Draw bounding box\nfunction addBoundingBox() {\n\tif ( APP.BackGroundColor == 'Black'){\n\t\t  var mat = new THREE.LineBasicMaterial( { color: 0xFFFFFF, linewidth: 2 } );\n\t\t  }\n\telse{\n\t\tvar mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } );\n\t\t}\n\n\tvar geometry = new THREE.BoxBufferGeometry( APP.BoundingboxX, APP.BoundingboxY, APP.BoundingboxZ );\n\tvar geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )\n\n\tvar boundingbox = new THREE.LineSegments( geo, mat );\n\tboundingbox.name = 'BoundingBox';\n\tboundingbox.scale.set(1,1,1);\n\tAPP.scene.add(boundingbox);\n\tAPP.BoundingBox = 'On';\n\tboundingbox.translateX( APP.BoundingboxX / 2.0 );\n\tboundingbox.translateY( APP.BoundingboxY / 2.0 );\n\tboundingbox.translateZ( APP.BoundingboxZ / 2.0 );\n\t}\n\nfunction removeBoundingBox(){\n\tvar obj = APP.scene.getObjectByName('BoundingBox');\n\tif ( obj != undefined ) {\n    \t\tAPP.scene.remove(obj);\n\t\t}\n\tAPP.BoundingBox = 'Off';\n\t}\n\nfunction setBoundingBoxColor(objcolor){\n\tvar obj = APP.scene.getObjectByName('BoundingBox');\n\tif ( obj != undefined ) {\n    \tobj.material.color.setHex( objcolor );\n\t\t}\n\t}\n\n","import { APP } from \"./APP\";\nimport { PaintTable } from \"./PaintTable\";\nimport _ from \"lodash\";\nimport { paintManager } from \"./SyncPaint\";\nimport { SurfaceTable } from \"./SurfaceTable\";\nimport { getSurfaceName } from \"./HandleSurfaces\";\nimport * as zlib from \"zlib\";\nimport {\n\tgetIntersect,\n\tannotateBySphere,\n\tgetCurrentParams,\n\tgetChanges,\n\tsetAnnotation,\n\tgetPaintID\n} from \"./three_annotator/index\";\n\nvar xratio = 0.6;\nvar yratio = 0.95;\nvar frustumSize = 1000;\n\nfunction animate() {\n\tAPP.renderer.render( APP.scene, APP.camera );\n\tAPP.controls.update();\n\trequestAnimationFrame( animate );\n};\n\n\nAPP.dragging = false;\nAPP.paint_mode = false;\nAPP.paint_on = true;\nAPP.paint_overwriteB = false;\n\n\n// Operation on mouse click\nfunction clickPosition( event ) {\n\tonDragStart(event);\n\t// Location of mouse\n\tvar clientX = event.clientX;\n\tvar clientY = event.clientY;\n\n\t// Normalization of location\n\tvar mouse = new THREE.Vector2();\n\tmouse.x = ( ( clientX - APP.renderer.domElement.offsetLeft ) / APP.renderer.domElement.clientWidth ) * 2 - 1;\n\tmouse.y = - ( ( clientY - APP.renderer.domElement.offsetTop ) / APP.renderer.domElement.clientHeight ) * 2 + 1;\n\n\t// Raycasterインスタンス作成\n\tvar raycaster = new THREE.Raycaster();\n\t// 取得したX、Y座標でrayの位置を更新\n\traycaster.setFromCamera( mouse, APP.camera );\n\n\t// Indetify crossing objects.\n\tvar intersects = raycaster.intersectObjects( APP.scene.children );\n\t\n\t// Obtain crossing surface objects.\n\tvar ids = [];\n\tvar intersected_surfaces = [];\n\tvar intersected_objects = [];\n\tfor (let i = 0; i < intersects.length; i++) {\n\t\tvar name = intersects[i].object.name;\n\t\tif (/^\\d*$/.test(name) && name.length === 10) { // /^\\d*$/ 符号や小数点を許容しない数値\n\t\t\t\tintersected_surfaces.push(intersects[i]);\n////\n\t\t\t  \tids = getPaintID({\n\t\t\t\t\tx: event.offsetX,\n\t\t\t\t\ty: event.offsetY,\n\t\t\t\t\tcamera: APP.camera,\n\t\t\t\t\tmeshes: APP.getMeshes(),\n\t\t\t\t\tcontainer: APP.renderer.domElement,\n\t\t\t  \t\t});\n////\n\t\t\t\t//console.log('ids: ', ids);\n\t\t\t}\n\t\tintersected_objects.push(intersects[i]);\n\t}\n\n\tif (APP.MarkerMode == 1 && intersected_surfaces.length > 0) {\n\t\t// If in the marker mode, put a marker  (this should be moved to HandleMarker.js).\n\t\tvar x = intersected_surfaces[ 0 ].point.x;\n\t\tvar y = intersected_surfaces[ 0 ].point.y;\n\t\tvar z = intersected_surfaces[ 0 ].point.z;\n\n\t\t//Append Jsontable\n\t\tvar markerName = APP.MarkerPrefix + String(APP.MarkerSuffix);\n\t\tAPP.addMarker({\n\t\t\tact: 1,\n\t\t\tname: markerName,\n\t\t\tparentid: name,\n\t\t\tradius: APP.MarkerRadius,\n\t\t\tr: APP.MarkerR,\n\t\t\tg: APP.MarkerG,\n\t\t\tb: APP.MarkerB,\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\tz: z\n\t\t});\n\t}\n\n\tconst target = document.getElementById(\"ClickedObjectID\");\n\tif (intersected_objects.length <= 0) {\n\t\ttarget.innerHTML = \"Background\";\n\t}else if (typeof ids[0] === \"undefined\") {\n\t\ttarget.innerHTML = intersected_objects[ 0 ].object.name;\n\t}else{\n\t\ttarget.innerHTML = intersected_objects[ 0 ].object.name +\"-\"+ids[0];\n\t} // endif\n}\n\n\nvar onDragStart = (event) => {\n  APP.dragging = true;\n\tannotate(event);\n}\n\nvar onDragEnd = (event) => {\n\tAPP.dragging = false;\n}\n\nvar annotate = (event) => {\n  if (!APP.dragging) {\n\tconst { intersect } = getIntersect({\n\t\tx: event.offsetX,\n\t\ty: event.offsetY,\n\t\tcamera: APP.camera,\n\t\tmeshes: APP.getMeshes(),\n\t\tcontainer: APP.renderer.domElement,\n\t})\n\tupdateCursor(intersect && intersect.point);\n\treturn;\n  };\n  if (!APP.paint_mode) return;\n  const { intersect } = annotateBySphere({\n\t\tx: event.offsetX,\n\t\ty: event.offsetY,\n\t\tcamera: APP.camera,\n\t\tmeshes: APP.getMeshes(),\n\t\tcontainer: APP.renderer.domElement,\n\t\tradius: getCursorRadius(APP.AnnotatorRadius),\n\t\tignoreBackFace: null,\n  });\n  updateCursor(intersect && intersect.point);\n  updateMetricsOnPaintTable()\n  syncAnnotation();\n};\n\n\nconst compress = paintData => paintData && zlib.gzipSync(Buffer.from(paintData)).buffer;\nconst decompress = compressedData => compressedData && new Uint8Array(zlib.gunzipSync(Buffer.from(compressedData)).buffer);\n\nconst syncAnnotation = _.debounce(() => {\n\tconst changes = getChanges({meshes: APP.getMeshes()});\n\tif(Object.keys(changes).length > 0) {\n\t\tfor(const objectChanges of Object.values(changes)) {\n\t\t\tfor(const colorChanges of Object.values(objectChanges)) {\n\t\t\t\tcolorChanges.painted = compress(colorChanges.painted);\n\t\t\t}\n\t\t}\n\t\tpaintManager.update({changes})\n\t}\n}, 1000, { maxWait: 1000 });\n\npaintManager.emitter.on(\"update\", data => {\n\tif(data.room_id !== \"list\") {\n\t\tconsole.log(data.room_id);\n\t\tconst [surfaceId, colorId] = data.room_id.split(\"-\");\n\t\tconst mesh = APP.getMeshes().find(mesh => mesh.name === surfaceId);\n\t\tif(!mesh) {\n\t\t\tconsole.error(\"mesh not found\")\n\t\t\treturn;\n\t\t}\n\t\tsetAnnotation({ mesh, colorId, data: {\n\t\t\t...data,\n\t\t\tpainted: decompress(data.painted),\n\t\t}})\n\t\tupdateMetricsOnPaintTable();\n\t}\n})\n\nconst getCursorRadius = annotatorRadius => (annotatorRadius || 0.3);\n\nconst updateCursor = position => {\n\tif (APP.cursor.visible === false) {\n\t\treturn;\n\t}\n\tconst radius = getCursorRadius(APP.AnnotatorRadius);\n\tconst cursor = APP.cursor;\n\tif (position) {\n\t\tcursor.position.copy(position);\n\t\tconst zoom = radius;\n\t\tcursor.scale.set(zoom, zoom, zoom);\n\t\tcursor.material.opacity = 0.3;\n\t} else {\n\t\tcursor.material.opacity = 0;\n\t}\n}\n\nexport const updateMetricsOnPaintTable = () => {\n\tconst activeSurfaces = new Set(SurfaceTable.getData()\n\t\t.filter(row => row.act)\n\t\t.map(row => getSurfaceName(row.id))\n\t);\n\tconst meshes = APP.getMeshes().filter(mesh => activeSurfaces.has(mesh.name));\n\tconst params = getCurrentParams({ meshes });\n\tconst areas = params.areas;\n\tconst newRows = PaintTable.getData(\"active\").map((item = {}) => {\n\t\treturn {\n\t\t\t...item,\n\t\t\tarea: areas[item.id]\n\t\t}\n\t})\n\tPaintTable.updateData(newRows);\n};\n\n\nAPP.getMeshes = () => {\n\treturn APP.scene.children.filter(object => object.type === \"Mesh\" && object.geometry.isBufferGeometry && !object.isCursor);\n}\n\n\nexport function launchAnnotator() {\n\n\t// Renderer\n\tvar container = document.getElementById('myCanvas');\n\tAPP.renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );\n\tAPP.renderer.setSize(window.innerWidth * xratio, window.innerHeight * yratio);\n\tcontainer.appendChild( APP.renderer.domElement );\n\n\t// Initilize camera\n\tAPP.camera = new THREE.PerspectiveCamera();\n\n\t// Scene\n\tAPP.scene = new THREE.Scene();\n\tAPP.scene.add( APP.camera );\n\n\t// Background Color\n\tAPP.scene.background = new THREE.Color( 0xffffff );\n\tAPP.BackGroundColor == 'White';\n\n\t// Light\n\tAPP.directionalLight = new THREE.DirectionalLight(0xffffff);\n\tAPP.directionalLight.position.set(0, 10, 0);  //default; light shining from top\n\tAPP.directionalLight.target.position.set(0, 0, 0);  //default; light shining from top\n\tAPP.directionalLight.intensity = 0.8;\n\t//APP.camera.add( APP.directionalLight );\n\tAPP.scene.add( APP.directionalLight );\n\n\t\n\tAPP.ambientLight = new THREE.AmbientLight( 0xffffff );\n\tAPP.ambientLight.intensity = 0.5;\n\tAPP.camera.add( APP.ambientLight );\n\n\t// var min = 0 ;\n\t// var max = 255 ;\n\n\t// Controlsを用意\n\tAPP.controls = new THREE.TrackballControls( APP.camera, APP.renderer.domElement );\n\tAPP.controls.rotateSpeed = 10;\n    APP.controls.staticMoving = false;\n\tAPP.controls.dynamicDampingFactor = 1.0; // staticMoving = false のときの減衰量\n\tanimate();\n\n\t// Response to mouse click\n\tAPP.renderer.domElement.addEventListener( 'mousedown', clickPosition, false );\n\tAPP.renderer.domElement.addEventListener('mouseup', onDragEnd, false);\n\tAPP.renderer.domElement.addEventListener('onmousemove', annotate, false);\n\tAPP.renderer.domElement.onmousemove = annotate;\n\n\t// Paint\n\t// Cursor\n\tvar geometry = new THREE.SphereBufferGeometry( 1, 32, 32 );\n\tvar material = new THREE.MeshLambertMaterial( {color: 0xffffff, opacity: 0, transparent: true, depthWrite: false} );\n\tvar cursor = new THREE.Mesh( geometry, material );\n\tcursor.isCursor = true;\n\tcursor.name = 'cursor';\n\tAPP.cursor = cursor;\n\tAPP.cursor.visible = false;\n\tAPP.scene.add( cursor );\n\n    // Marker\n\tAPP.MarkerMode = 0;\n\tAPP.MarkerR = 255;\n\tAPP.MarkerG = 0;\n\tAPP.MarkerB = 0;\n\tAPP.MarkerPrefix = \"Marker\";\n\tAPP.MarkerSuffix = 0;\n\tAPP.MarkerRadius = 0.1;\n\tAPP.MarkerID     = 1;\n\n\t// Surface opacity\n\tAPP.surface_opacity          = 1.0;\n\tAPP.surface_opacity_reserved = 0.5;\n\n\t// Skeleton\n\tAPP.SkeletonMode = 0;\n\n\t// Sphere\n\tAPP.SphereMode   = 0;\n\n\t//Boundingbox\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/surface/VolumeDescription.json\";\n\t$.getJSON(call_url).done(function(data) {\n\t\t//data_parsed = JSON.parse(data);\n\t\tconsole.log(data)\n        APP.BoundingboxX = data.boundingbox_um.x;\n\t\tAPP.BoundingboxY = data.boundingbox_um.y;\n\t\tAPP.BoundingboxZ = data.boundingbox_um.z;\n\t\tAPP.BoundingboxMax = Math.max(APP.BoundingboxX, APP.BoundingboxY, APP.BoundingboxZ);\n\t\tconsole.log('APP.BoundingboxMax: ', APP.BoundingboxMax)\n\t\t\n\t\twindow.CenterXY()\n\t\tAPP.directionalLight.target.position.set(APP.BoundingboxX/2.0, APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0); \n\t\twindow.DirLightX(false)\n\t\twindow.DirLightY(false)\n\t\twindow.DirLightZ(false)\n\t\t\n\t\t// https://threejsfundamentals.org/threejs/lessons/threejs-lights.html\n    });\n}\n","//\n//\n//\n//\n//\nimport { APP } from \"./APP\";\nimport { parseCSV, csvFormatter } from \"./csv\";\nimport { MarkerTable } from \"./MarkerTable\";\n\n/**\n * マーカーを追加する\n *\n * @param {Object} markerData CSVで読み込まれたプロパティを持つオブジェクト。以下のプロパティが有効\n *   - act      : {number} 例: 1\n *   - name     : {string} 例: \"Marker1\"\n *   - parentid : {number} 例: 3036\n *   - radius   : {number} 例: 2.8\n *   - r        : {number} 例: 255\n *   - g        : {number} 例: 30\n *   - b        : {number} 例: 100\n *   - x        : {number} 例: 9.076891761740626\n *   - y        : {number} 例: 10.850928915374125\n *   - z        : {number} 例: 252.16774396931498\n *\n * @param {bool} [isImportFromFile=false] ファイルからの読み込みかどうか。\n *   ファイルからの読み込み時はMarkerがOFFでもMarkerTableに追加する\n * @return {bool} マーカーを追加したらtrueが返る\n */\n\nAPP.addMarker = function(markerData, isImportFromFile) {\n  var markerData_act = Number(markerData.act);\n  var markerData_name = String(markerData.name);\n  var markerData_parentid = Number(markerData.parentid);\n  var markerData_radius = Number(markerData.radius);\n  var markerData_r = Number(markerData.r);\n  var markerData_g = Number(markerData.g);\n  var markerData_b = Number(markerData.b);\n  var markerData_x = Number(markerData.x);\n  var markerData_y = Number(markerData.y);\n  var markerData_z = Number(markerData.z);\n\n  // CSVファイルからの読み込み時はMarkerがOFFでも描画する(要確認)\n  if (APP.MarkerMode == 1 || isImportFromFile) {\n    var color = rgb2hex([markerData_r, markerData_g, markerData_b]);\n\n    // Add sphere\n    var geometry = new THREE.SphereGeometry(1);\n    var material = new THREE.MeshBasicMaterial({ color: color });\n    var sphere = new THREE.Mesh(geometry, material);\n\n    sphere.scale.set(markerData_radius, markerData_radius, markerData_radius);\n    sphere.position.set(markerData_x, markerData_y, markerData_z);\n    sphere.name = 'm' + APP.MarkerID.toString();\n    APP.scene.add(sphere);\n\n    var NewMarker = {\n      act: markerData_act,\n      id: APP.MarkerID,\n      name: markerData_name,\n      parentid: markerData_parentid,\n      radius: markerData_radius,\n      r: markerData_r,\n      g: markerData_g,\n      b: markerData_b,\n      x: markerData_x,\n      y: markerData_y,\n      z: markerData_z\n    };\n    MarkerTable.addData(NewMarker);  // Change database MarkerTable (setData)\n    updateMarkerId();\n    return true;\n  }\n  return false;\n};\n\n\nfunction rgb2hex ( rgb ) {\n\treturn \"#\" + rgb.map( function ( value ) {\n\t\treturn ( \"0\" + value.toString( 16 ) ).slice( -2 ) ;\n\t} ).join( \"\" ) ;\n}\n\n/**\n * MarkerIDを更新する\n */\nfunction updateMarkerId() {\n  APP.MarkerSuffix = APP.MarkerSuffix + 1;\n  APP.MarkerID = APP.MarkerID + 1;\n  $('#SetSuffixNum').val(APP.MarkerSuffix); // Change suffix for index.html\n};\n\n/**\n * マーカーを描画する\n *\n * @example\n * renderMarker({\n *   \"act\": 1,\n *   \"name\": \"test1\",\n *   \"parentid\": 3000,\n *   \"radius\": 2,\n *   \"r\": 100,\n *   \"g\": 0,\n *   \"b\": 0,\n *   \"x\": 100,\n *   \"y\": 200,\n *   \"z\": 200\n * })\n *\n * @param {Object} markerData CSVで読み込まれたプロパティを持つオブジェクト。addMarkerの引数と同じ\n */\nAPP.renderMarker = function(markerData) {\n  var obj = APP.scene.getObjectByName(Number(markerData.parentid));\n  if (obj == null) {\n    return false;\n  }\n  return APP.addMarker(markerData, true);\n};\n\n\n// Change the color of the stl object specified by a name after generation.\nAPP.changeMarkerRadius = function(id, r){\n\tvar name = 'm'+ id.toString();\n\tvar obj = APP.scene.getObjectByName(name);\n\tconsole.log(obj);\n\tif ( obj != undefined ) {\n    \t\tobj.scale.set(r,r,r);\n\t\t}\n\t}\n\n// Change the color of the stl object specified by a name after generation.\nAPP.changeMarkerColor = function(id, objcolor){\n\tvar name = 'm'+ id.toString();\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n    \t\tobj.material.color.setHex( objcolor );\n\t\t}\n\t}\n\n// Remove a stl object by a name after generation.\nAPP.removeMarker = function(id){\n\t// Remove from scene\n\tvar name = 'm'+ id.toString();\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n    APP.scene.remove(obj);\n\t}\n}\n\n\n","//\n//\n//\n//\n//\nimport { APP } from \"./APP\";\nimport { parseCSV, csvFormatter } from \"./csv\";\nimport * as hdf5 from 'jsfive';\nimport { MarkerTable } from \"./MarkerTable\";\nimport { SurfaceTable } from \"./SurfaceTable\";\n\n// Change the opacity of all surface objects\n\nAPP.addSkeletons = function() {\n\tAPP.scene.traverse(function(obj) {\n\t\tif ( (obj instanceof THREE.Mesh === true) && (obj.visible === true) && (obj.name.length === 10) ) {\n\t\t\tvar id  = obj.name - 0;\n\t\t\tvar col = obj.material.color;\n\t\t\tAPP.addSkeletonObject(id, col)\n\t\t}\n\t});\n}\n\nAPP.removeSkeletons = function() {\n\tAPP.scene.traverse(function(obj) {\n\t\tif ( obj.name.match(/line/) ) {\n\t\t\tobj.visible = false;\n\t\t}\n\t});\n}\n\n\n// Add stl objects and a name\nAPP.generateSkeletons = function() {\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/ws/surface_skeleton\";\n\n\tconst skel_scale       = document.getElementById(\"SkelScale\"); \n\tconst skel_constant    = document.getElementById(\"SkelConstant\"); \n\tconst skel_min_voxels  = document.getElementById(\"SkelMinVoxels\"); \n\tconst skel_max_paths   = document.getElementById(\"SkelMaxPaths\"); \n\tconst skel_smoothness  = document.getElementById(\"SkelSmoothness\"); \n\tconst skel_extra_after = document.getElementsByName(\"SkelExtraAfter\"); \n\n\tvar request = {};\n\trequest[\"mode\"]      = \"skeleton\";\n\trequest[\"scale\"]     = String(skel_scale.value);\n\trequest[\"constant\"]  = String(skel_constant.value);\n\trequest[\"min_voxel\"] = String(skel_min_voxels.value);\n\trequest[\"max_path\"]  = String(skel_max_paths.value);\n\trequest[\"smooth\"]    = String(skel_smoothness.value);\n\trequest[\"extra_after\"] = String(skel_extra_after.value) === 'true';\n\trequest[\"element\"]   = [];\n\t// Get JSON variable that shows the skeletons \"ids and colors\", and associated markers.\n\tvar rows = SurfaceTable.searchRows(\"act\", \"=\",  true);\n\tfor (var i in rows) {\n\t\tvar id  = rows[i].getData().id;\n  \t\tvar r   = rows[i].getData().r;\n  \t\tvar g   = rows[i].getData().g;\n  \t\tvar b   = rows[i].getData().b;\n  \t\tvar col = r*256*256+g*256+b*1;\n\t\t//console.log('Target id: ', id);\n\t\tvar element = {}\n\t\telement.id = id\n\t\telement.color = col\n\t\t// Remove current skeleton\n\t\tvar name = 'line' + ( '0000000000' + id ).slice( -10 );\n\t\tvar obj = APP.scene.getObjectByName(name);\n\t\tif ( obj != undefined ) {\n\t\t\t//obj.geometry.dispose();\n\t\t\t//obj.material.dispose();\n    \t\tAPP.scene.remove(obj);\n    \t\tAPP.disposeNode(obj);\n\t\t}\n\t\t// Get marker points\n  \t\tvar rows_marker = MarkerTable.searchRows(\"parentid\", \"=\",  id);\n  \t\tvar markerlocs = [];\n\t\tfor (var j in rows_marker) {\n\t\t\t\tvar id_marker  = rows_marker[j].getData().id;\n\t\t\t\tvar mx = rows_marker[j].getData().x;\n\t\t\t\tvar my = rows_marker[j].getData().y;\n\t\t\t\tvar mz = rows_marker[j].getData().z;\n\t\t\t\t//console.log('Marker id: ', id_marker);\n\t\t\t\t//console.log('x,y,z: ',mx,my,mz);\n\t\t\t\tmarkerlocs.push([mx, my, mz])\n\t\t\t\t}\n\t\telement.markerlocs = markerlocs\n\t\tconsole.log('element: ', element)\n\t\trequest[\"element\"].push(element)\n\t\t}\n\t// console.log(request)\n\n\n\t//Send request to Server\n\tvar req = new XMLHttpRequest();\n\treq.onreadystatechange = function()\n\t{\n\t    var READYSTATE_COMPLETED = 4;\n\t    var HTTP_STATUS_OK = 200;\n\n\t    if( this.readyState == READYSTATE_COMPLETED\n\t     && this.status == HTTP_STATUS_OK )\n\t    {\n\t        // レスポンスの表示\n\t        if (this.responseText == \"False\") {\n\t\t\t\talert(\"No skeleton.\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t    }\n\t}\n\treq.open( 'POST', call_url , false);\n\treq.setRequestHeader( 'Content-Type', 'application/json' );\n\treq.send(JSON.stringify(request));\n\n\tfor (const elem of request[\"element\"]) {\n\t\tconsole.log(\"Element: \", elem)\n\t\tAPP.addSkeletonObject(elem.id, elem.color)\n\t\t}\n\n\t}\n//\n\n\n// Add stl objects and a name\nAPP.addSkeletonObject = function(id, col) {\n\n\tif (APP.SkeletonMode == 0){\n\t\treturn false;\n\t\t}\n\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/ws/surface_skeleton\";\n\tconst target_url = location.protocol+\"//\"+location.host+\"/skeleton/whole/\" + ( '0000000000' + id ).slice( -10 ) + \".hdf5\";\n\tconst filename   = ( '0000000000' + id ).slice( -10 ) + \".hdf5\";\n\tconst name       = 'line' + ( '0000000000' + id ).slice( -10 );\n\t\n\t// Revive if it already exists.\n\t// console.log('Name: ', name)\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\t// console.log('Obj: ', obj)\n\t\tobj.visible = true;\n\t\treturn true;\n\t\t}\n\n\t// Request the surface mesh generation to the server if it does not exist.\n\tvar xhr = new XMLHttpRequest();\n\txhr.open(\"HEAD\", target_url, false);  //同期モード promise method\n\txhr.send(null);\n\tif(xhr.status == 404) {\n\t\t\t\t// alert(\"No skeleton.\");\n\t\t\t\tconsole.log('No skeleton data:', id);\n\t\t\t\treturn false;\n\t\t}\n\n\t//\n\tfetch(target_url)\n\t  .then(function(response) {\n\t    return response.arrayBuffer() \n\t  })\n\t  .then(function(buffer) {\n\t    //\n\t    //\n\t    var f = new hdf5.File(buffer, filename);\n\t    let g1 = f.get('vertices');\n\t    let g2 = f.get('edges');\n\t    var data_vertices = g1.value;\n\t    var data_edges    = g2.value;\n\t    \n\t    data_vertices = splitArray(data_vertices, 3);\n\t    data_edges    = splitArray(data_edges, 2);\n\t    \n\t    \n\t\tvar i1 = undefined;\n\t\tvar i2 = undefined;\n\t\tvar v1 = undefined;\n\t\tvar v2 = undefined;\n\t\t// console.log(data_vertices)\n\t\t// console.log('Length vertices: ' + data_vertices.length);\n\t\t// console.log('Length edges   : ' + data_edges.length);\n\t\t\n\t\t////// Uncaught TypeError: Cannot read property '0' of undefined\n\t\t\n\t\tif (typeof data_vertices !== \"object\"){\n \t\t\tconsole.log('Not skeleton data.');\n\t\t\treturn false;\n\t\t}\n\t\tif(typeof(data_vertices[0])===\"undefined\"){\n\t\t\tconsole.log('Errornous skeleton data.');\n\t\t\tconsole.log(data_vertices);\n\t\t\treturn false;\n\t\t}\n\t\tif (isNaN(data_vertices[0][0]) == true) {\n\t\t\t// console.log(data_vertices);\n\t\t\tconsole.log('Errornous skeleton data.');\n\t\t\treturn false;\n\t\t}\n\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.LineBasicMaterial({\n\t\t\tcolor: col,  //0x000000\n\t\t\tlinewidth: 3,\n\t\t\tfog:true\n\t\t});\n\t\t\n\t\tfor(let i=0;i< data_edges.length;i++){\n\t\t\ti1 = data_edges[i][0];\n\t\t\ti2 = data_edges[i][1];\n\n//\t\t\tconsole.log('Vertices ID: ', i1, i2 );\n//\t\t\tconsole.log('data_vertices[i1]: ', data_vertices[i1] );\n//\t\t\tconsole.log('data_vertices[i2]: ', data_vertices[i2] );\n\n\t\t\tv1 = new THREE.Vector3( data_vertices[i1][0], data_vertices[i1][1], data_vertices[i1][2]);\n\t\t\tv2 = new THREE.Vector3( data_vertices[i2][0], data_vertices[i2][1], data_vertices[i2][2]);\n\t\t\tgeometry.vertices.push(v1, v2);\n\t\t\t}\n\t\tvar line = new THREE.LineSegments( geometry, material );   \n\t\t\n\t\t\n\t\tline.name = name;\n\t\t// console.log(line.name);\n\t\tAPP.scene.add( line );\t    \n\t    //\n\t    //\n\t    //\n\t  });\n\t}\n\n\n// Change the color of a skeleton object specified by a name.\nAPP.changeSkeletonObjectColor = function(id, col) {\n\tname = 'line' + ( '0000000000' + id ).slice( -10 );\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\tobj.material.color.setHex( col );\n\t\t}\n\t}\n\n\n// Remove a stl object by the name.\nAPP.removeSkeletonObject = function(id) {\n\tname = 'line' + ( '0000000000' + id ).slice( -10 );\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\t// APP.scene.remove(obj);\n\t\tobj.visible = false;\n\t\t}\n\t}\n\n\nfunction splitArray(array, part) {\n    var tmp = [];\n    for(var i = 0; i < array.length; i += part) {\n        tmp.push(array.slice(i, i + part));\n    }\n    return tmp;\n}\n\n\n\n\n\n","//\n//\n//\n//\n//\nimport { APP } from \"./APP\";\nimport { parseCSV, csvFormatter } from \"./csv\";\nimport * as hdf5 from 'jsfive';\nimport { SurfaceTable } from \"./SurfaceTable\";\n\n// Change the opacity of all surface objects\n\nAPP.addSpheres = function() {\n\t\n\tvar rows = SurfaceTable.searchRows(\"act\", \"=\",  true);\n\tfor (var i in rows) {\n\t\tvar id  = rows[i].getData().id;\n  \t\tvar r   = rows[i].getData().r;\n  \t\tvar g   = rows[i].getData().g;\n  \t\tvar b   = rows[i].getData().b;\n  \t\tvar col = r*256*256+g*256+b*1;\n  \t\tAPP.addSphereObject(id, col);\n  \t}\n\n}\n\nAPP.removeSpheres = function() {\n\tAPP.scene.traverse(function(obj) {\n\t\tif ( obj.name.match(/Spheres/) ) {\n\t\t\tobj.visible = false;\n\t\t}\n\t});\n}\n\n\n// Add stl objects and a name\nAPP.addSphereObject = function(id, col) {\n\n\tif (APP.SphereMode == 0){\n\t\treturn false;\n\t\t}\n\n\tconst target_url = location.protocol+\"//\"+location.host+\"/skeleton/whole/\" + ( '0000000000' + id ).slice( -10 ) + \".hdf5\";\n\tconst filename   = ( '0000000000' + id ).slice( -10 ) + \".hdf5\";\n\tconst name       = 'Spheres' + ( '0000000000' + id ).slice( -10 );\n\t\n\t// Revive if it already exists.\n\t// console.log('Name: ', name)\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\t// console.log('Obj: ', obj)\n\t\tobj.visible = true;\n\t\treturn true;\n\t\t}\n\t\n\t//\n\tfetch(target_url)\n\t  .then(function(response) {\n\t    return response.arrayBuffer() \n\t  })\n\t  .then(function(buffer) {\n\t    //\n\t    //\n\t    var f = new hdf5.File(buffer, filename);\n\t    let g1 = f.get('vertices');\n\t    let g2 = f.get('edges');\n\t    let g3 = f.get('radiuses');\n\t    let g4 = f.get('tangents');\n\t    var data_vertices = g1.value;\n\t    var data_edges    = g2.value;\n\t    var data_radiuses = g3.value;\n\t    var data_tangents = g4.value;\n\t    \n\t    data_vertices = splitArray(data_vertices, 3);\n\t    data_edges    = splitArray(data_edges, 2);\n\t    data_radiuses = splitArray(data_radiuses, 1);\n\t    data_tangents = splitArray(data_tangents, 3);\n\t    \n\t\tvar i1 = undefined;\n\t\tvar i2 = undefined;\n\t\tvar v1 = undefined;\n\t\tvar v2 = undefined;\n\t\t// console.log(data_vertices)\n\t\t// console.log('Length vertices: ' + data_vertices.length);\n\t\t// console.log('Length edges   : ' + data_edges.length);\n\t\tif (isNaN(data_vertices[0][0]) == true) {\n\t\t\t// console.log(data_vertices);\n\t\t\tconsole.log('No morphological data.');\n\t\t\treturn false;\n\t\t}\n\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.LineBasicMaterial({\n\t\t\tcolor: col,  //0x000000\n\t\t\tlinewidth: 3,\n\t\t\tfog:true\n\t\t});\n\t\t\n\t\t\n\t\tvar spheres = new THREE.Group();\n\t\tfor(var i=0;i< data_edges.length;i++){\n\t\t\ti1 = data_edges[i][0];\n\t\t\ti2 = data_edges[i][1];\n\n\t\t\t// console.log('Vertices ID: ', i1, i2 );\n\n\t\t\tv1 = new THREE.Vector3( data_vertices[i1][0], data_vertices[i1][1], data_vertices[i1][2]);\n\t\t\tv2 = new THREE.Vector3( data_vertices[i2][0], data_vertices[i2][1], data_vertices[i2][2]);\n\t\t\tgeometry.vertices.push(v1, v2);\n\n\n\t\t\t// Create circle object\n\t\t\tvar radius = data_radiuses[i1];\n\t\t\tif ( (i1 % 10 == 1) && (radius > 0.01) ) {\n\t\t\t\t// if ( data_vertices[i1][2] <= APP.BoundingboxZ * 0.05 ) {continue;}\n\t\t\t\t// if ( data_vertices[i1][1] <= APP.BoundingboxY * 0.05 ) {continue;}\n\t\t\t\t// if ( data_vertices[i1][0] <= APP.BoundingboxX * 0.05 ) {continue;}\n\t\t\t\t// if ( data_vertices[i1][2] >= APP.BoundingboxZ * 0.95 ) {continue;}\n\t\t\t\t// if ( data_vertices[i1][1] >= APP.BoundingboxY * 0.95 ) {continue;}\n\t\t\t\t// if ( data_vertices[i1][0] >= APP.BoundingboxX * 0.95 ) {continue;}\n\t\t\t\t// console.log(data_vertices[i1][0], data_vertices[i1][1], data_vertices[i1][2]);\n\t\t\t\n\t\t\t\tconst geometry  = new THREE.CircleGeometry( radius, 20);\n\t\t\t\tconst material  = new THREE.MeshPhongMaterial( {color: col, opacity: 0.3, transparent: true, side: THREE.DoubleSide} );\n\t\t\t\tconst vertice_r = new THREE.Mesh( geometry, material );\n\t\t\t\tvertice_r.position.set(data_vertices[i1][0], data_vertices[i1][1], data_vertices[i1][2]);\n\t\t\t\tvar theta_z = Math.atan(data_tangents[i1][1] / data_tangents[i1][0])\n\t\t\t\tvar theta_x = Math.acos(data_tangents[i1][2])\n\t\t\t\t//vertice_r.lookAt(new THREE.Vector3(0, 0, 0));\n\t\t\t\t//vertice_r.rotation.set(rx,0,rz)\n\t\t\t\t\n\t\t\t\tvar q = new THREE.Quaternion();\n\t\t\t\tvar axis1 = new THREE.Vector3(0,0,1);\n\t\t\t\tvar axis2 = new THREE.Vector3(data_tangents[i1][0], data_tangents[i1][1], data_tangents[i1][2]);\n\t\t\t\tq.setFromUnitVectors ( axis1, axis2 ) ;\n\t\t\t\tvertice_r.quaternion.multiply( q );\n\n\n\t\t\t\t//vertice_r.quaternion.multiply( q );\n\t\t\t\tspheres.add( vertice_r )\n\n\t\t\t\t}\n\t\t\t}\n\t\tvar line = new THREE.LineSegments( geometry, material );\n\t\tspheres.add( line )\n\n\t\tspheres.name = name;\n\t\tAPP.scene.add( spheres );\n\t    //\n\t    //\n\t  });\n\t}\n\n\n// Change the color of a skeleton object specified by a name.\nAPP.changeSphereObjectColor = function(id, col) {\n\tname = 'Spheres' + ( '0000000000' + id ).slice( -10 );\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\tobj.material.color.setHex( col );\n\t\t}\n\t}\n\n\n// Remove a stl object by the name.\nAPP.removeSphereObject = function(id) {\n\tname = 'Spheres' + ( '0000000000' + id ).slice( -10 );\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\t// APP.scene.remove(obj);\n\t\tobj.visible = false;\n\t\t}\n\t}\n\n\nfunction splitArray(array, part) {\n    var tmp = [];\n    for(var i = 0; i < array.length; i += part) {\n        tmp.push(array.slice(i, i + part));\n    }\n    return tmp;\n}\n\n\n\n\n\n","//\n//\n//\n//\n//\nimport { APP } from \"./APP\";\nimport { parseCSV, csvFormatter } from \"./csv\";\nimport { updateColorOptionsOnAnnotator } from \"./PaintTable\";\nimport { paintManager } from \"./SyncPaint\";\nimport { SurfaceTable } from \"./SurfaceTable\";\n\nexport const getSurfaceName = id => {\n\treturn ( '0000000000' + id ).slice( -10 );\n}\n\n// Add surface objects and a name\nAPP.addSurfaceObject = function(id, col) {\n\n\tif (APP.SphereMode == 1){\n\t\treturn false;\n\t\t}\n\n\tconst name =  getSurfaceName(id);\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/ws/surface_skeleton\";\n\tconst target_url = location.protocol+\"//\"+location.host+\"/surface/whole/\" + name + \".stl\";\n\n\t// Revive it if already exists.\n\t// console.log('Name: ', name)\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\t// console.log('Obj: ', obj)\n\t\tobj.visible = true;\n\t\tobj.material.opacity = APP.surface_opacity;\n\t\tpaintManager.addSurface(name);\n\t\treturn true;\n\t\t}\n\n\t// Request the surface mesh generation to the server if it does not exist.\n\tvar xhr = new XMLHttpRequest();\n\txhr.open(\"HEAD\", target_url, false);  //同期モード promise method\n\txhr.send(null);\n\tif(xhr.status == 404) {\n\n\t\t// Obtain smoothing option\n\t\tconst SmoothMeth = document.getElementsByName(\"SmoothingMethod\"); // document.SmoothingMethod;\n\t\tconst NumIter = document.getElementById(\"SmoothingNumIters\"); // SmoothingNumIters;\n\t\tlet Smeth = \"\";\n\t\tfor (let i = 0; i < SmoothMeth.length; i++){\n\t\t\tif(SmoothMeth[i].checked){ //(SmoothMeth[i].checked === true)と同じ\n\t\t\t\tSmeth = SmoothMeth[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//Send request\n\t\tvar data = { mode: \"surface\", id: id, smooth_method: Smeth, num_iter: String(NumIter.value) }; // POSTメソッドで送信するデータ\n\t\tvar req = new XMLHttpRequest();\n\t\treq.onreadystatechange = function()\n\t\t{\n\t\t    var READYSTATE_COMPLETED = 4;\n\t\t    var HTTP_STATUS_OK = 200;\n\n\t\t    if( this.readyState == READYSTATE_COMPLETED\n\t\t     && this.status == HTTP_STATUS_OK )\n\t\t    {\n\t\t        // レスポンスの表示\n\t\t        if (this.responseText == \"False\") {\n\t\t\t\t\talert(\"No surface.\");\n\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t    }\n\t\t}\n\t\treq.open( 'POST', call_url , false);\n\t\t// サーバに対して解析方法を指定する\n\t\treq.setRequestHeader( 'Content-Type', 'application/json' );\n\t\t// データをリクエスト ボディに含めて送信する\n\t\treq.send(JSON.stringify(data));\n//\n\n//\t\t\t以前、GET methodで\n//\t\t\tvar req = new XMLHttpRequest();\n//\t\t\treq.open(\"get\", call_url+id, false);\n//\t\t\treq.send(null);\n//\t\t\tif (req.responseText == \"False\") {\n//\t\t\t\talert(\"No surface.\");\n//\t\t\t\treturn false;\n//\t\t\t\t}\n\t}\n\n\n\t// console.log('Mesh prepared.');\n\n\t// Load the stl file then generate mesh object.\n\tvar loader = new THREE.STLLoader();\n\tloader.load(target_url, function(bufferGeometry) {\n\t  if (bufferGeometry.isBufferGeometry) {\n\t\t  bufferGeometry.attributes.color = bufferGeometry.attributes.color || bufferGeometry.attributes.position.clone();\n\t\t  bufferGeometry.attributes.color.array.fill(1);\n\t\t  bufferGeometry.attributes.color.needsUpdate = true;\n\t\t  bufferGeometry.colorsNeedUpdate = true;\n\t  }\n\t  // console.log('Stl loaded.');\n\t  const meshMaterial = new THREE.MeshPhongMaterial({\n\t\t  color: col,\n\t\t  specular: 0x776666,\n\t\t  shininess: 0.2,\n\t\t  vertexColors: THREE.FaceColors,\n\t\t  transparent: true,\n\t\t  opacity: APP.surface_opacity,\n\t\t  side: THREE.DoubleSide\n\t  }) // APP.surface_opacity\n\t  var mesh = new THREE.Mesh(bufferGeometry, meshMaterial);\n      mesh.name = name;\n      mesh.scale.set(1, 1, 1);\n      // mesh.material.side = THREE.DoubleSide;\n      APP.scene.add(mesh);\n\n\t  // console.log(mesh.name);\n\n\t  updateColorOptionsOnAnnotator();\n\t  paintManager.addSurface(name);\n\t});\n}\n\n// Change the opacity of all surface objects\n\n\nAPP.changeSurfaceObjectOpacity = function(opacity) {\n\t// console.log('Input opacity: ', opacity)\n\tvar invisible = 0;\n\tif ( opacity == -2 ){\n\t\tinvisible = 1;\n\t} else if ( opacity == -1 ){\n\t\tAPP.surface_opacity = 1;\n\t} else if (opacity == 0) {\n\t\tAPP.surface_opacity = APP.surface_opacity_reserved;\n\t} else {\n\t\tAPP.surface_opacity = opacity;\n\t\tAPP.surface_opacity_reserved = opacity;\n\t};\n\n\tvar rows = SurfaceTable.searchRows(\"act\", \"=\",  true);\n\tfor (var i in rows) {\n\t\tvar id  = rows[i].getData().id;\n  \t\tvar r   = rows[i].getData().r;\n  \t\tvar g   = rows[i].getData().g;\n  \t\tvar b   = rows[i].getData().b;\n\t\tif (invisible == 1) {\n\t\t\tAPP.removeSurfaceObject(id);\n\t\t\tAPP.removeSkeletonObject(id);\n\t\t} else {\n\t\t\tvar col = r*256*256+g*256+b*1 ;\n\t\t\tAPP.addSurfaceObject(id, col);\n\t\t\tAPP.addSkeletonObject(id, col);\n\t\t}\n\t}\n}\n// if (obj instanceof THREE.Mesh === true && /^\\d*$/.test(obj.name) && obj.name.length === 10 ) {\n\n\n// Change the color of a surface object specified by the name.\nAPP.changeSurfaceObjectColor = function(id, objcolor) {\n\tconst name =  getSurfaceName(id);\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n    \t\tobj.material.color.setHex( objcolor );\n\t\t}\n\t}\n\n\n// Remove a stl object by a name after generation.\nAPP.removeSurfaceObject = function(id) {\n\tconst name =  getSurfaceName(id);\n\tvar obj = APP.scene.getObjectByName(name);\n\tif ( obj != undefined ) {\n\t\t// APP.scene.remove(obj);\n\t\tobj.visible = false;\n\t\t}\n\t\tpaintManager.removeSurface(name);\n\t}\n\n\n\n","import { APP } from \"./APP\";\nimport { parseCSV, csvFormatter } from \"./csv\";\nimport * as Tabulator from \"tabulator-tables\";\n\nexport const MarkerTable = new Tabulator(\"#MarkerTable\", {\n\tlayout:\"fitColumns\",      //fit columns to width of table\n\tautoResize:true,\n\tresponsiveLayout:\"hide\",  //hide columns that dont fit on the table\n\ttooltips:true,            //show tool tips on cells\n\taddRowPos:\"top\",          //when adding a new row, add it to the top of the table\n\thistory:true,             //allow undo and redo actions on the table\n\tpagination:\"local\",       //paginate the data\n\tpaginationSize:10,         //allow 7 rows per page of data\n\tresizableRows:true,       //allow row order to be changed\n\tinitialSort:[             //set the initial sort order of the data\n\t\t{column:\"id\", dir:\"dsc\"},\n\t],\n\tcolumns:[                 //define the table columns\n    // ActやX,Y,Zはダウンロード時に除外されないよう定義しておく。ただしカラムvisible: falseにして非表示にする\n    {title:\"Act\", field: \"act\", download: true, visible: false},\n\t\t{title:\"Delete\", formatter:\"buttonCross\", width: 73, hozAlign:\"center\", editor:\"tickCross\", editable: onDeleteCheck, download: false},\n\t\t{title:\"ID\", field:\"id\", width: 40},\n\n    // マーカー名を入力する時に日本語などASCII外が入力されないようにする\n    // 入力されるとCSVファイルダウンロード→インポートを通して文字化けが発生するため、[ a-zA-Z0-9_-] のみ使用可能とする\n\t\t{title:\"Name\", field:\"name\", width: 70, editor:\"input\", validator: function(cell, value, parameters) {\n      return util.isMarkerName(value);\n    }},\n\n\t\t{title:\"Parent ID\", field:\"parentid\", width: 70},\n\t\t{title:\"Radius\", field:\"radius\", width: 60, hozAlign:\"right\", editor:\"number\",editorParams:{min:0.01, max:1, step:0.01}},\n\t\t{title:\"R\", field:\"r\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\n\t\t{title:\"G\", field:\"g\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\n\t\t{title:\"B\", field:\"b\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\n    {title:\"X\", field:\"x\", download: true, visible: false},\n    {title:\"Y\", field:\"y\", download: true, visible: false},\n    {title:\"Z\", field:\"z\", download: true, visible: false}\n\t],\n\n  // セルが編集されたとき\n  cellEdited: function(cell) {\n    // 渡ってくるパラメータcellについて: http://tabulator.info/docs/4.1/components#component-cell\n    // 編集後の値\n    var cellValue = cell.getValue();\n    // 編集前の値\n    var cellOldValue = cell.getOldValue();\n    // 編集対象のセルがある列\n    var row = cell.getRow();\n    var act = row.getData().act;\n    var id  = row.getData().id;\n    var radius  = row.getData().radius;\n    var r   = row.getData().r;\n    var g   = row.getData().g;\n    var b   = row.getData().b;\n    var columnField = cell.getColumn().getField();\n\n    if (columnField == 'radius') {\n      APP.changeMarkerRadius(id, radius);\n    }\n\n    if (columnField == 'r' || columnField == 'g' || columnField == 'b') {\n      APP.changeMarkerColor(id, r*256*256+g*256+b*1);\n    }\n   }\n});\n\n\n// 「Import CSV」ボタンを押したとき\n$('#import-csv-marker-table').on('change', onImportCSVFileSelect);\n\n// 「Clear」ボタンを押したら3Dマーカーをクリアする\n$('#clear-marker-table').on('click', function(event) {\n  clearMarkerTable();\n  return false;\n});\n\n// 「Download CSV」ボタンを押したとき\n$('#save-marker-table-csv').on('click', function(event) {\n  downloadMarkerTableAsCSV();\n  return false;\n});\n\n\n// Deleteのチェックが押されたとき\nfunction onDeleteCheck(cell) {\n  var data = cell.getRow().getData();\n  APP.removeMarker(data.id);\n  cell.getRow().delete();\n}\n\n// 「Import CSV」ボタンが押されてファイルを選択したとき\nfunction onImportCSVFileSelect(event) {\n  var file = event.originalEvent.target.files[0];\n\n  var reader = new FileReader();\n  reader.onload = function(e) {\n    var csvFileContent = e.target.result;\n    var parsedData = parseCSV(csvFileContent);\n\n    // 1行目のタイトルを除外\n    parsedData.shift();\n    // タイトルフィールドを変換\n    var markers = replaceColumnTitle(MarkerTable, parsedData);\n\n    // 同じ座標のためスキップした数\n    var sameCoordinatesCount = 0;\n    // Parent ID のオブジェクトが非表示のためスキップした数\n    var parentNotVisibleCount = 0;\n\n    markers.forEach(function(markerData) {\n      if (!validateMarkerDataType(markerData)) {\n        // 不正な値があったらスキップ\n        console.error(\"Invalid marker data\", markerData);\n      } else if (!validateMarkerDataXYZ(markerData)) {\n        // すでに同じ座標で定義済みだったらスキップ\n        console.warn(\"Skipped: The loaded marker has been defined as same coordinates.\", markerData);\n        sameCoordinatesCount++;\n      } else {\n        var isAdded = APP.renderMarker(markerData);\n        if (!isAdded) {\n          // Parent ID のオブジェクトが非表示だったらエラーを出す\n          console.warn(\"Skipped: The loaded marker's parent object has not visible.\", markerData);\n          parentNotVisibleCount++;\n        }\n      }\n    });\n\n    var errorMsg = [];\n    if (sameCoordinatesCount) {\n      errorMsg.push(sameCoordinatesCount + \" Skipped: The loaded marker has been defined as same coordinates.\");\n    }\n    if (parentNotVisibleCount) {\n      errorMsg.push(parentNotVisibleCount + \" Skipped: The loaded marker's parent object has not visible.\");\n    }\n    if (errorMsg.length) {\n      // スキップしたとき毎回アラートを出すとアラート数が増えすぎるのでまとめて通知する\n      alert(errorMsg.join(\"\\n\"));\n    }\n\n    // 選択したファイル情報をクリア。これをしないと同じファイルを再度読み込めない\n    $('#import-csv-marker-table').val('');\n  };\n  reader.readAsText(file);\n}\n\n/**\n * MarkerTableが空かどうか\n *\n * @return {bool}\n */\nfunction isMarkerTableEmpty() {\n  return MarkerTable.getDataCount() === 0;\n}\n\n/**\n * MarkerTableをクリアする\n */\nfunction clearMarkerTable() {\n  var rows = MarkerTable.getRows();\n  rows.forEach(function(row) {\n    APP.removeMarker(row.getData().id);\n    row.delete();\n  });\n}\n\n/**\n * MarkerTableをCSVでダウンロードする\n */\nfunction downloadMarkerTableAsCSV() {\n  MarkerTable.download(csvFormatter, 'MarkerTable.csv');\n}\n\n/**\n * テーブルカラムのタイトルとフィールドのペアを取得する\n *\n * @example\n * getColumnFieldTitlePairs(MarkerTable)\n * {\n *   \"Act\": \"act\"\n *   \"ID\": \"id\"\n *   \"Name\": \"name\"\n *   \"Parent ID\": \"parentid\"\n *   \"Radius\": \"radius\"\n *   \"R\": \"r\"\n *   \"G\": \"g\"\n *   \"B\": \"b\"\n *   \"X\": \"x\"\n *   \"Y\": \"y\"\n *   \"Z\": \"z\"\n * }\n */\nfunction getColumnFieldTitlePairs(table) {\n  var columnDefinitions = table.getColumnDefinitions();\n  var fieldTitlePairs = {};\n  columnDefinitions.forEach(function(column) {\n    fieldTitlePairs[column.title] = column.field;\n  });\n  return fieldTitlePairs;\n}\n\n/**\n * キーがのタイトルのJSONデータをフィールド名にを変換する\n * CSVの1行目タイトルは表記用のものでスペースも含まれるため、内部キー名に変換する\n *\n * @example\n * replaceColumnTitle(MarkerTable, {\n *   \"Act\": \"1\"\n *   \"ID\": \"2\"\n *   \"Name\": \"Marker1\"\n *   \"Parent ID\": \"3036\"\n *   \"Radius\": \"2\"\n *   \"R\": \"255\"\n *   \"G\": \"0\",\n *   ...\n * });\n *\n * // 以下のようになる\n * {\n *   \"act\": \"1\"\n *   \"id\": \"2\"\n *   \"name\": \"Marker1\"\n *   \"parentid\": \"3036\"\n *   \"radius\": \"2\"\n *   \"r\": \"255\"\n *   \"g\": \"0\",\n *   ...\n * }\n */\nfunction replaceColumnTitle(table, json) {\n  var fieldTitlePairs = getColumnFieldTitlePairs(table);\n  return json.reduce(function(memo, data) {\n    var newData = {};\n    Object.keys(data).forEach(function(key) {\n      var value = data[key];\n      var newKey = fieldTitlePairs[key];\n      newData[newKey] = value;\n    });\n    memo.push(newData);\n    return memo;\n  }, []);\n}\n\n\n/**\n * renderMarkerに渡されるパラメータが適切な値かチェックする\n * CSVファイルから読まれ不正な値の可能性があるので扱える値かどうかを調べる\n *\n * @param  {Object} markerData renderMarkerの引数と同じ\n * @return {bool} すべての値が適切ならtrue,そうじゃないならfalse\n */\nfunction validateMarkerDataType(markerData) {\n  if (!util.isNumeric(markerData.act)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.id)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.parentid)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.radius)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.r)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.g)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.b)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.x)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.y)) {\n    return false;\n  }\n  if (!util.isNumeric(markerData.z)) {\n    return false;\n  }\n  if (!util.isMarkerName(markerData.name)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * CSVファイルから読み込んだMarkerデータで、表示中のMarkerTableと同じ座標のものがあるかチェックする\n *\n * @param  {Object} markerData renderMarkerの引数と同じ\n * @return {bool} すべての値が適切ならtrue,そうじゃないならfalse\n */\nfunction validateMarkerDataXYZ(markerData) {\n  var rows = MarkerTable.getRows();\n  return rows.every(function(row) {\n    var rowData = row.getData();\n    var rowX = rowData.x;\n    var rowY = rowData.y;\n    var rowZ = rowData.z;\n    var markerDataX = Number(markerData.x);\n    var markerDataY = Number(markerData.y);\n    var markerDataZ = Number(markerData.z);\n\n    // 浮動小数点数のため、小数点2桁までで比較する。だいたい同じ座標かどうかチェックする\n    if (rowX.toFixed(2) === markerDataX.toFixed(2) &&\n        rowY.toFixed(2) === markerDataY.toFixed(2) &&\n        rowZ.toFixed(2) === markerDataZ.toFixed(2)) {\n      // 同じ座標\n      return false;\n    }\n    return true;\n  });\n}\n","import { APP } from \"./APP\";\nimport { updatePaintObservation, paintManager } from \"./SyncPaint\";\nimport { setColorOptions } from \"./three_annotator/index\";\nimport * as Tabulator from \"tabulator-tables\";\n\nconst mutatorClip = (value, data, type, mutatorParams, component) => {\n  const min = mutatorParams.min;\n  const max = mutatorParams.max;\n  return value <= min ? min :\n         value >= max ? max :\n         value;\n}\n\nconst mutatorParamsClip = {min: 0, max: 255};\n\n// 0-1までのなるべく離れた値を返す\nconst reversalBit = index => {\n  let original = index, fraction = 1, value = 0;\n  while(original) {\n    const bit = original % 2;\n    original = (original - bit) / 2;\n    fraction /= 2;\n    value += bit * fraction;\n  }\n  return value;\n}\n\n// 彩度が最大で、なるべく異なる色相の色を返す\nconst getRandomColor = (index) => {\n  const value = ((reversalBit(index - 1)) % 1) * 3;\n  const mainColorType = Math.floor(value);\n  const subColorValue = Math.floor((value - mainColorType) * 255);\n  const colors = [subColorValue, 255 - subColorValue];\n  colors.splice(mainColorType, 0, 0);\n  return {\n    r: colors[0],\n    g: colors[1],\n    b: colors[2],\n  }\n}\n\nexport const updateColorOptionsOnAnnotator = () => {\n  updatePaintObservation();\n  const activeColors = [];\n  const colorParams = {\n    eraser: {r: 1, g: 1, b: 1},\n  };\n  const tableData = PaintTable.getData(\"active\");\n  let targetColorId = null;\n  for (const row of tableData) {\n    colorParams[row.id] = {r: row.r / 255, g: row.g / 255, b: row.b / 255};\n    if(row.target) {\n      targetColorId = row.id;\n    } else if (row.visibility) {\n      activeColors.push(row.id);\n    }\n  }\n  if(targetColorId) {\n    activeColors.unshift(targetColorId);\n  }\n\n  let colorOptions = {\n    activeColors: activeColors,\n    colorParams: colorParams,\n    eraser: !APP.paint_on,\n    overwrite: APP.paint_overwriteB\n  }\n  setColorOptions(colorOptions, {meshes: APP.getMeshes()});\n};\n\nexport const PaintTable = new Tabulator('#PaintTable', {\n\tlayout:\"fitColumns\",\n\tautoResize:true,\n\tresponsiveLayout:\"hide\",\n\ttooltips:true,\n\taddRowPos:\"top\",\n\thistory:true,\n\tpagination:\"local\",\n\tpaginationSize:10,\n\tresizableRows:true,\n\tmovableRows: true,\n\tinitialSort:[],\n\tcolumns:[\n      {title: \"Delete\", formatter: \"buttonCross\",  hozAlign: \"center\", cellClick: (e, cell) => {cell.getRow().delete()}, headerSort:false},\n      {title: \"Visible\", field:\"visibility\", width: 73, hozAlign:\"center\", formatter:\"tickCross\", headerSort:false, cellClick: (e, cell)=>{\n        const value = cell.getRow().getData();\n        cell.setValue(!value.visibility || value.target);\n        updateColorOptionsOnAnnotator();\n        updateMetricsOnPaintTable();\n    }},\n      {title: \"Target\", field:\"target\", width: 73, hozAlign:\"center\", formatter:\"tickCross\", headerSort:false, cellClick: (e, cell)=>{\n        const table = PaintTable;\n        const value = cell.getRow().getData();\n        table.setData(table.getData(\"active\").map(item => { \n          item = Object.assign({}, item);\n          item.debug = true;\n          item.target = value.id == item.id;\n          item.visibility = item.visibility || item.target;\n          return item;  \n        }))\n        updateColorOptionsOnAnnotator();\n      }},\n\t    {title: \"ID\", field:\"id\", width: 40, headerSort:false},\n\t    {title: \"Name\", field: \"name\", editor: \"input\", headerSort:false, cellEdited: () => updateColor()},\n   \t  {title: \"R\", field: \"r\", minWidth: 30, width: 35, hozAlign: \"right\", visible: true, editor: \"number\", editorParams: {min:0, max: 255, step: 1}, mutator: mutatorClip, mutatorParams: mutatorParamsClip, headerSort:false, cellEdited: () => updateColor()},\n\t    {title: \"G\", field: \"g\", minWidth: 30, width: 35, hozAlign: \"right\", visible: true, editor: \"number\", editorParams: {min:0, max: 255, step: 1}, mutator: mutatorClip, mutatorParams: mutatorParamsClip, headerSort:false, cellEdited: () => updateColor()},\n\t    {title: \"B\", field: \"b\", minWidth: 30, width: 35, hozAlign: \"right\", visible: true, editor: \"number\", editorParams: {min:0, max: 255, step: 1}, mutator: mutatorClip, mutatorParams: mutatorParamsClip, headerSort:false, cellEdited: () => updateColor()},\n\t    {title: \"Area\", field: \"area\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}},\n\t    {title: \"Volume\", field: \"volume\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}},\n\t    {title: \"Area reserv\", field: \"area_reserv\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}, visible: false},\n\t    {title: \"Length\", field: \"length\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}, visible: false},\n\t    {title: \"Max r\", field: \"max_radius\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}, visible: false},\n\t    {title: \"Mean r\", field: \"max_radius\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}, visible: false},\n\t    {title: \"Min r\", field: \"min_radius\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}, visible: false}\n\t],  \n  rowMoved: (row) => {\n    updateColor();\n  },\n  rowDeleted: (row) => {\n    updateColor();\n  },\n  rowAdded: (row) => {\n    updateColor();\n  }\n});\n\n\nconst updateColor = () => {\n  updateColorOptionsOnAnnotator()\n  paintManager.updateList({ list: PaintTable.getData(), lastPaintId })\n};\n\nwindow.switchAnnotation = (checked) => {\n\tAPP.paint_mode = checked;\n\tAPP.controls.noRotate = checked;\n}; \n\nwindow.switchEraserAnnotation = (checked) => {\n\tAPP.paint_on = checked;\n  updateColorOptionsOnAnnotator()\n};\n\nwindow.setAnnotationOverwrite = (checked) => {\n  APP.paint_overwriteB = checked;\n  updateColorOptionsOnAnnotator()\n}\n\nlet lastPaintId = 0;\n$('#button-add-paint-layer').on('click', (event) => {\n    lastPaintId++;\n    const hasTarget = PaintTable.getData(\"active\").some(item => item.target);\n    var layer = Object.assign({id: lastPaintId, name: \"Layer\" + String(lastPaintId), area:0, volume: 0, visibility: true, target: !hasTarget}, getRandomColor(lastPaintId));\n    PaintTable.addData(layer);\n    updateColorOptionsOnAnnotator()\n});\n\n$('#save-paint-table-csv').on('click', (event) => {\n  downloadPaintTableAsCSV();\n});\n\n\n//// 201016\n\n$('#calc-volumes').on('click', (event) => {\n\tpaintManager.updatePaintVolumes()\n});\n\n\n//// 211223\nconst downloadPaintTableAsCSV = () => {\n  const tableData = PaintTable.getData(\"active\");\n  const csvData = [[\"id\", \"name\", \"r\", \"g\", \"b\", \"area\", \"volume\", \"area_reserv\", \"length\",\"max_radius\",\"mean_radius\",\"min_radius\"]]\n  for (const row of tableData) {\n    csvData.push([row.id, row.name, row.r, row.g, row.b, row.area, row.volume, row.area_reserv, row.length, row.max_radius, row.mean_radius, row.min_radius]);\n  }\n\n/*\n  const csvData = [[\"id\", \"name\", \"r\", \"g\", \"b\", \"area\", \"volume\"]]\n  for (const row of tableData) {\n    csvData.push([row.id, row.name, row.r, row.g, row.b, row.area, row.volume]);\n  }\n*/\n\n  const csvContent = \"data:text/csv;charset=utf-8,\" +\n  csvData.map(e => e.join(\",\")).join(\"\\n\");\n  const encodeUri = encodeURI(csvContent);\n  // window.open(encodeUri); This also download CSV file\n  \n  const link = document.createElement(\"a\");\n  link.setAttribute(\"href\", encodeUri);\n  link.setAttribute(\"download\", \"paint.csv\");\n  document.body.appendChild(link);\n  link.click();\n};\n\nconst syncSequence = true;\n\npaintManager.emitter.on(\"update\", data => {\n  if(data.room_id === \"list\") {\n    const currentRows = PaintTable.getData() || [];\n    const incomingRows = data.list || [];\n\n    console.log(incomingRows);\n\n    if(syncSequence) { \n      const currentRowsMap = new Map(currentRows.map(currentRow => [currentRow.id, currentRow]));\n      PaintTable.setData(incomingRows.map(incomingRow => {\n        const currentRow = currentRowsMap.get(incomingRow.id);\n        return {\n          visibility: true,\n          ...currentRow,\n          id: incomingRow.id,\n          name: incomingRow.name,\n          r: incomingRow.r,\n          g: incomingRow.g,\n          b: incomingRow.b,\n          volume: incomingRow.volume,\n          area_reserv: incomingRow.area_reserv,\n          length: incomingRow.length,\n          max_radius: incomingRow.max_radius,\n          mean_radius: incomingRow.mean_radius,\n          min_radius: incomingRow.min_radius,\n        }\n      }));\n    } else {\n      const incomingRowsMap = new Map(incomingRows.map(incomingRow => [incomingRow.id, incomingRow]));\n      const newRows = [];\n      for(const currentRow of currentRows) {\n        if(incomingRowsMap.has(currentRow.id)) {\n          const incomingRow = incomingRowsMap.get(currentRow.id);\n          newRows.push({\n            ...currentRow,\n            name: incomingRow.name,\n            r: incomingRow.r,\n            g: incomingRow.g,\n            b: incomingRow.b,\n          \tvolume: incomingRow.volume,\n          \tarea_reserv: incomingRow.area_reserv,\n          \tlength: incomingRow.length,\n          \tmax_radius: incomingRow.max_radius,\n          \tmean_radius: incomingRow.mean_radius,\n          \tmin_radius: incomingRow.min_radius,\n          })\n          incomingRowsMap.delete(currentRow.id);\n        }\n      }\n      for(const [id, incomingRow] of incomingRowsMap) {\n        newRows.push({\n          id: incomingRow.id,\n          visibility: true,\n          name: incomingRow.name,\n          r: incomingRow.r,\n          g: incomingRow.g,\n          b: incomingRow.b,\n          volume: incomingRow.volume,\n          area_reserv: incomingRow.area_reserv,\n          length: incomingRow.length,\n          max_radius: incomingRow.max_radius,\n          mean_radius: incomingRow.mean_radius,\n          min_radius: incomingRow.min_radius,\n        });\n      }\n      PaintTable.setData(newRows);\n    }\n    lastPaintId = data.lastPaintId || 0;\n    updateColorOptionsOnAnnotator()\n  }\n})\n","import { APP } from \"./APP\";\nimport { csvFormatter } from \"./csv\";\nimport { updateMetricsOnPaintTable } from \"./HandleBasement\";\nimport * as Tabulator from \"tabulator-tables\";\n\nexport const SurfaceTable = new Tabulator(\"#SurfaceTable\", {\n\tajaxURL:\"./surface/segmentInfo.json\",\n\tlayout:\"fitColumns\",      //fit columns to width of table\n\tautoResize:true,\n\tresponsiveLayout:\"hide\",  //hide columns that dont fit on the table\n\ttooltips:true,            //show tool tips on cells\n\taddRowPos:\"top\",          //when adding a new row, add it to the top of the table\n\thistory:true,             //allow undo and redo actions on the table\n\tpagination:\"local\",       //paginate the data\n\tpaginationSize:10,         //allow 7 rows per page of data\n\tresizableRows:true,       //allow row order to be changed\n\tinitialSort:[             //set the initial sort order of the data\n\t\t{column:\"name\", dir:\"asc\"},\n\t],\n\tcolumns:[                 //define the table columns\n    // ActやConfidenceはダウンロード時に除外されないよう定義しておく。ただしカラムvisible: falseにして非表示にする\n    {title:\"Act\", field: \"act\", download: true, visible: false},\n\t\t{title:\"Visible\", field:\"act\", width: 73, hozAlign:\"center\",formatter:\"tickCross\", cellClick: (e, cell)=>{cell.setValue(!cell.getValue());}, download: false},\n\t\t{title:\"ID\", field:\"id\", width: 50},\n\t\t{title:\"Name\", field:\"name\", editor:\"input\"},\n\t\t{title:\"Size\", field:\"size\", width:60, hozAlign:\"right\"},\n    {title:\"Confidence\", field: \"confidence\", download: true, visible: false},\n\t\t{title:\"R\", field:\"r\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\n\t\t{title:\"G\", field:\"g\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\n\t\t{title:\"B\", field:\"b\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\n\t],\n\n\t// セルが編集されたとき\n  cellEdited: function(cell) {\n      // 渡ってくるパラメータcellについて: http://tabulator.info/docs/4.1/components#component-cell\n      // 編集後の値\n      var cellValue = cell.getValue();\n      // 編集前の値\n      var cellOldValue = cell.getOldValue();\n      // 編集対象のセルがある列\n      var row = cell.getRow();\n      var act = row.getData().act;\n      var id  = row.getData().id;\n      var r   = row.getData().r;\n      var g   = row.getData().g;\n      var b   = row.getData().b;\n      // 編集したセルに対するカラムのフィールド\n      var columnField = cell.getColumn().getField();\n      // console.log(\"編集後の値:\", cellValue, \"編集前の値:\", cellOldValue, \"編集した列:\", row, \"編集したカラム\", columnField);\n\n\n\t  var col = r*256*256+g*256+b*1 ;\n\t  if(columnField == 'act') {\n\t  \tif(act == true) {\n\t  \t\tconsole.log(\"Requested ID:\", id );\n\t\t\tAPP.addSurfaceObject(id, col);\n\t\t\tAPP.addSkeletonObject(id, col);\n\t\t\tAPP.addSphereObject(id, col);\n\t\t\t}\n\t  \tif(act == false) {\n\t  \t\tconsole.log(\"Disappear ID:\", id )\n\t\t\t//const filename = sprintf(\"./stls/i%d.stl\", id );\n\t\t\tAPP.removeSurfaceObject(id);\n\t\t\tAPP.removeSkeletonObject(id);\n\t\t\tAPP.removeSphereObject(id);\n\t\t\t}\n\t\t\tupdateMetricsOnPaintTable();\n\t\t}\n\t  if(columnField == 'r' || columnField == 'g' || columnField == 'b') {\n\t  \tconsole.log(\"Changecolor ID:\", id )\n\t\tAPP.changeSurfaceObjectColor(id, col);\n\t\tAPP.changeSkeletonObjectColor(id, col);\n\t\t}\n    }\n\n});\n\n// 「Download CSV」ボタンを押したとき\n$('#save-object-table-csv').on('click', function(event) {\n  downloadSurfaceTableAsCSV();\n  return false;\n});\n\n/**\n * ObjectTableをCSVでダウンロードする\n */\nfunction downloadSurfaceTableAsCSV() {\n  console.log(\"downloadObjectTableAsCSV\");\n  SurfaceTable.download(csvFormatter, 'SurfaceTable.csv');\n}\n","import { PaintTable } from \"./PaintTable\";\nimport { SurfaceTable } from \"./SurfaceTable\";\nimport crypto from \"crypto\";\nimport EventEmitter from \"events\";\nimport io from \"socket.io-client\";\n\nexport const socket = io(`${location.origin}/`);\nsocket.on('system', data => {\n  console.log('system', data);\n});\n\nconst subtract  = function *(a, b) {\n  for(const item of a) {\n    if(!b.has(item)) {\n      yield item;\n    }\n  }\n}\n\nclass RoomManager {\n  values = new Map();\n  emitter = new EventEmitter();\n  constructor(socket) {\n    this.socket = socket;\n    this.socket.on('update', this.onUpdateData);\n    this.socket.on('current', this.onUpdateData);\n  }\n  onUpdateData = data => {\n    const currentData = this.values.get(data.room_id);\n    if(!currentData || (currentData.sid || this.socket.id) !== this.socket.id || data.sid !== this.socket.id) {\n      this.values.set(data.room_id, data);\n      this.emitter.emit(\"update\", data);\n    }\n  }\n  enterRoom(roomId) {\n    this.socket.emit(\"enter\", roomId)  \n  }\n  leaveRoom(roomId) {\n    this.socket.emit(\"leave\", roomId);\n    this.values.delete(roomId);\n  }\n}\n\nclass PaintManager extends RoomManager{\n  colors = new Set();\n  surfaces = new Set();\n\n  getRoomId({surface, color}) {\n    return `${surface}-${color}`;\n  }\n\n  addColor(color) {\n    for(const surface of this.surfaces) {\n      this.enterRoom(this.getRoomId({color, surface}));\n    }\n    this.colors.add(color);\n  }\n  removeColor(color) {\n    for(const surface of this.surfaces) {\n      this.leaveRoom(this.getRoomId({color, surface}));\n    }\n    this.colors.delete(color);\n  }\n  addSurface(surface) {\n    for(const color of this.colors) {\n      this.enterRoom(this.getRoomId({color, surface}));\n    }\n    this.surfaces.add(surface);\n  }\n  removeSurface(surface) {\n    for(const color of this.colors) {\n      this.leaveRoom(this.getRoomId({color, surface}));\n    }\n    this.surfaces.delete(surface);\n  }\n  update(data) {\n    for(const [objectId, objectData] of Object.entries(data.changes)) {\n      for(const [colorId, colorData] of Object.entries(objectData)) {\n        const roomId = objectId + \"-\" + colorId;\n        this.values.set(roomId, colorData);\n      }\n    }\n    this.socket.emit(\"update_paint\", data)\n  }\n  \n  // 200116 HU\n  updatePaintVolumes() {\n    this.socket.emit(\"update_paint_volumes\")\n  }\n  //\n  \n  updateList({ list, lastPaintId }) {\n    this.socket.emit(\"update\", {\n      list,\n      lastPaintId,\n      room_id: \"list\"\n    })\n  }\n}\n\n\nexport const paintManager = new PaintManager(socket);\n\nlet oldActiveColors = new Set();\nexport const updatePaintObservation = () => {\n  const activeColors = new Set();\n  const tableData = PaintTable.getData(\"active\");\n  for (const row of tableData) {\n    if (row.visibility) {\n      activeColors.add(row.id);\n    }\n  }\n  for(const item of subtract(oldActiveColors, activeColors)) {\n    paintManager.removeColor(item);\n  }\n  for(const item of subtract(activeColors, oldActiveColors)) {\n    paintManager.addColor(item);\n  } \n  oldActiveColors = activeColors;\n}\n","// TabulatorのcsvFormatterに不具合があるため再定義する\n// csvFormatter from Download.prototype.downloaders in tabulator.js\nexport const csvFormatter = function(columns, data, options, setFileContents, config) {\n  // TabulatorのcsvFormatterは隠れてるカラムがダウンロード対象にならないためカラムを再定義する\n  var columnDefinitions = this.table.getColumnDefinitions();\n  columns = columnDefinitions.filter(function(column) {\n    return column.download !== false;\n  });\n\n  var self = this,\n    titles = [],\n    fields = [],\n    delimiter = options && options.delimiter ? options.delimiter : \",\",\n    fileContents;\n\n  //build column headers\n  function parseSimpleTitles() {\n    columns.forEach(function (column) {\n      titles.push('\"' + String(column.title).split('\"').join('\"\"') + '\"');\n      fields.push(column.field);\n    });\n  }\n\n  function parseColumnGroup(column, level) {\n    if (column.subGroups) {\n      column.subGroups.forEach(function (subGroup) {\n        parseColumnGroup(subGroup, level + 1);\n      });\n    } else {\n      titles.push('\"' + String(column.title).split('\"').join('\"\"') + '\"');\n      fields.push(column.definition.field);\n    }\n  }\n\n  if (config.columnGroups) {\n    console.warn(\"Download Warning - CSV downloader cannot process column groups\");\n    columns.forEach(function (column) {\n      parseColumnGroup(column, 0);\n    });\n  } else {\n    parseSimpleTitles();\n  }\n\n  //generate header row\n  fileContents = [titles.join(delimiter)];\n\n  function parseRows({ data }) {\n    //generate each row of the table\n    data.forEach(function (row) {\n      var rowData = [];\n\n      fields.forEach(function(field) {\n        // getFieldValueを使うと数値がfalseになるため単純にrowの値を使う\n        //var value = self.getFieldValue(field, row);\n        var value = row[field];\n\n        switch (typeof value) {\n          case \"object\":\n            value = JSON.stringify(value);\n            break;\n          case \"undefined\":\n          case \"null\":\n            value = \"\";\n            break;\n        }\n\n        //escape quotation marks\n        rowData.push('\"' + String(value).split('\"').join('\"\"') + '\"');\n      });\n\n      fileContents.push(rowData.join(delimiter));\n    });\n  }\n\n  function parseGroup(group) {\n    if (group.subGroups) {\n      group.subGroups.forEach(function (subGroup) {\n        parseGroup(subGroup);\n      });\n    } else {\n      parseRows(group.rows);\n    }\n  }\n\n  if (config.rowGroups) {\n    console.warn(\"Download Warning - CSV downloader cannot process row groups\");\n    data.forEach(function (group) {\n      parseGroup(group);\n    });\n  } else {\n    parseRows(data);\n  }\n\n  setFileContents(fileContents.join(\"\\n\"), \"text/csv\");\n};\n\n\n/**\n * カンマ区切りのCSV文字列から配列に変換する\n *\n * @param  {string} csv カンマ区切りの文字列\n * @return {Array}  変換した配列\n */\nexport function parseCSV(csv) {\n  var result = [];\n  var array = csv2array(csv);\n\n  for (var i = 1; i < array.length; i++) {\n    result[i - 1] = {};\n    for (var k = 0; k < array[0].length && k < array[i].length; k++) {\n      var key = array[0][k];\n      result[i - 1][key] = array[i][k];\n    }\n  }\n\n  return result;\n}\n\n/**\n * カンマ区切りCSVの一行を配列に変換する\n *\n * 参考: RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files\n * https://tools.ietf.org/html/rfc4180\n * https://stackoverflow.com/questions/33155999/converting-a-csv-file-into-a-2d-array/33156233\n *\n * @param  {string} csv カンマ区切りの文字列\n * @param  {string} [delimiter=','] 区切り文字。デフォルト=','\n * @return {array} カンマ区切りをを変換した配列\n */\nfunction csv2array(csv, delimiter) {\n  delimiter = delimiter || ',';\n\n  var pattern = new RegExp(\n    // [1] delimiter\n    '(\\\\' + delimiter + '|\\\\r?\\\\n|\\\\r|^)' +\n    '(?:' +\n      // [2] quoted value\n      '\"([^\"]*(?:\"\"[^\"]*)*)\"|' +\n      // [3] standard value\n      '([^\"\\\\' + delimiter + '\\\\r\\\\n]*)'+\n    ')',\n    'gi'\n  );\n\n  var array = [[]];\n  var m, matchedDelimiter, matchedValue;\n\n  while ((m = pattern.exec(csv))) {\n    matchedDelimiter = m[1];\n    if (matchedDelimiter.length && matchedDelimiter !== delimiter) {\n      array.push([]);\n    }\n\n    if (m[2]) {\n      matchedValue = m[2].replace(/\"\"/g, '\"');\n    } else {\n      matchedValue= m[3];\n    }\n    array[array.length - 1].push(matchedValue);\n  }\n\n  return array;\n}\n","import \"../js/ControlAnnotator\";\nimport \"../js/csv\";\nimport \"../js/MarkerTable\";\nimport \"../js/util\";\nimport \"../js/SurfaceTable\";\nimport \"../js/HandleSurfaces\";\nimport \"../js/HandleSkeletons\";\nimport \"../js/HandleSpheres\";\nimport \"../js/HandleMarkers\";\nimport \"../js/SyncPaint\";\n\nimport \"../js/three_annotator/index\";\nimport \"../js/three_annotator/geometryState\";\n\nimport { launchAnnotator } from \"../js/HandleBasement\";\nlaunchAnnotator();\n","class GeometryColor {\n  constructor(length) {\n    this.painted = new Int8Array(length);\n    this.totalArea = 0;\n    this.updated = false;\n  }\n  clear() {\n    this.painted.fill(0);\n    this.totalArea = 0;\n  }\n}\n\nclass GeometryState {\n  totalArea = 0;\n  geometryColors = {};\n  constructor(geometry) {\n    this.geometry = geometry;\n    this.initArea();\n  }\n  initArea() {\n    const vertexCount = this.geometry.attributes.position.count;\n    const faceCount = vertexCount / 3;\n    this.areas = new Float32Array(faceCount);\n    const positionArray = this.geometry.attributes.position.array;\n    const length = positionArray.length;\n    for (let i = 0; i < length; i += 9) {\n      const face_area = calcArea(\n        positionArray[i + 0],\n        positionArray[i + 1],\n        positionArray[i + 2],\n        positionArray[i + 3],\n        positionArray[i + 4],\n        positionArray[i + 5],\n        positionArray[i + 6],\n        positionArray[i + 7],\n        positionArray[i + 8]\n      );\n      this.areas[i / 9] = face_area / 3;\n    }\n  }\n  activeColors = [0, 1, 2];\n  targetColorId = 0;\n  colorParams = {\n    0: { r: 1, g: 0, b: 0 },\n    1: { r: 0, g: 1, b: 0 },\n    2: { r: 0, g: 0, b: 1 },\n    eraser: { r: 1, g: 1, b: 1 },\n  };\n  eraserColorId = \"eraser\";\n  overwrite = true;\n\n\n  getChanges() {\n    const response = {};\n    for (const colorId of this.activeColors) {\n      const geometryColor = this.geometryColors[colorId];\n      if(geometryColor?.updated) {\n        response[colorId] = {\n          painted: geometryColor.painted,\n          totalArea: geometryColor.totalArea, \n        };\n        geometryColor.updated = false;\n      }\n    } \n    return response;\n  }\n\n  setAnnotation(colorId, data) {\n    const geometryColor = this.getGeometryColor(colorId);\n    if(data.painted) {\n      geometryColor.painted = data.painted;\n      geometryColor.totalArea = data.totalArea;\n      this.updateAllColor();\n    }\n  }\n\n  getGeometryColor(colorId) {\n    if (!this.geometryColors[colorId]) {\n      const vertexCount = this.geometry.attributes.position.count;\n      this.geometryColors[colorId] = new GeometryColor(vertexCount);\n    }\n    return this.geometryColors[colorId];\n  }\n  updateAllColor() {\n    const colorArray = this.geometry.attributes.color.array;\n    const vertexCount = colorArray.length / 3;\n    for (let i = 0; i < vertexCount; i += 1) {\n      this.updateColor(i);\n    }\n    this.geometry.attributes.color.needsUpdate = true;\n    this.geometry.colorsNeedUpdate = true;\n  }\n  updateColor(vertexIndex) {\n    let effecientColorId = this.eraserColorId;\n    for (const colorId of this.activeColors) {\n      if (this.geometryColors[colorId]?.painted[vertexIndex]) {\n        effecientColorId = colorId;\n        break;\n      }\n    }\n    const colorArray = this.geometry.attributes.color.array;\n    const colorParam = this.colorParams[effecientColorId];\n    colorArray[vertexIndex * 3 + 0] = colorParam.r;\n    colorArray[vertexIndex * 3 + 1] = colorParam.g;\n    colorArray[vertexIndex * 3 + 2] = colorParam.b;\n  }\n\n//////////////\n  getColorId(vertexIndex) {\n\t  var ids  = [];\n\t  for (const colorId of this.activeColors) {\n\t    const geometryColor = this.getGeometryColor(colorId);\n\t\tif (geometryColor.painted[vertexIndex] == 1) {\n\t\t\tids.push(colorId);\n\t\t\t}\n\t\t}\n\t  return ids;\n  }\n//////////////\n\n\n  setColor(vertexIndex) {\n    if (this.overwrite) {\n      for (const colorId of this.activeColors) {\n        const geometryColor = this.getGeometryColor(colorId);\n        if (colorId === this.targetColorId) {\n          if (geometryColor.painted[vertexIndex] === 0) {\n            geometryColor.painted[vertexIndex] = 1;\n            geometryColor.totalArea += this.areas[Math.floor(vertexIndex / 3)];\n            geometryColor.updated = true;\n          }\n        } else {\n          if (geometryColor.painted[vertexIndex] === 1) {\n            geometryColor.painted[vertexIndex] = 0;\n            geometryColor.totalArea -= this.areas[Math.floor(vertexIndex / 3)];\n            geometryColor.updated = true;\n          }\n        }\n      }\n      const colorArray = this.geometry.attributes.color.array;\n      const colorParam = this.colorParams[\n        this.eraser ? this.eraserColorId : this.targetColorId\n      ];\n      colorArray[vertexIndex * 3 + 0] = colorParam.r;\n      colorArray[vertexIndex * 3 + 1] = colorParam.g;\n      colorArray[vertexIndex * 3 + 2] = colorParam.b;\n      return true;\n    } else if (this.eraser) {\n      const geometryColor = this.getGeometryColor(this.targetColorId);\n      if (geometryColor.painted[vertexIndex] === 1) {\n        geometryColor.painted[vertexIndex] = 0;\n        geometryColor.totalArea -= this.areas[Math.floor(vertexIndex / 3)];\n        geometryColor.updated = true;\n        this.updateColor(vertexIndex);\n        return true;\n      }\n    } else {\n      const geometryColor = this.getGeometryColor(this.targetColorId);\n      if (geometryColor.painted[vertexIndex] === 0) {\n        geometryColor.painted[vertexIndex] = 1;\n        geometryColor.totalArea += this.areas[Math.floor(vertexIndex / 3)];\n        geometryColor.updated = true;\n        this.updateColor(vertexIndex);\n        return true;\n      }\n    }\n  }\n\n  setColorOptions({\n    targetColorId,\n    activeColors,\n    colorParams,\n    eraserColorId,\n    eraser,\n    overwrite,\n  }) {\n    this.activeColors = activeColors || this.activeColors;\n    this.eraserColorId = eraserColorId || this.eraserColorId;\n    this.colorParams = colorParams || this.colorParams;\n    this.eraser = eraser != null ? eraser : this.eraser;\n    this.overwrite = overwrite != null ? overwrite : this.overwrite;\n    this.targetColorId = this.eraser && this.overwrite\n      ? this.eraserColorId\n      : this.activeColors[0];\n    this.updateAllColor();\n  }\n\n  setColorParams(colorParams) {\n    this.colorParams = colorParams;\n    this.updateAllColor();\n  }\n  annotate({ center, direction, limit, ignoreBackFace }) {\n    window.geometryState = this;\n    const geometry = this.geometry;\n    const center_x = center.x,\n      center_y = center.y,\n      center_z = center.z;\n    const direction_x = direction.x,\n      direction_y = direction.y,\n      direction_z = direction.z;\n    let needsUpdate = false;\n    if (geometry.isBufferGeometry) {\n      const positionArray = geometry.attributes.position.array;\n      const normalArray = geometry.attributes.normal.array;\n      const length = positionArray.length;\n      for (let i = 0; i < length; i += 3) {\n        const x = positionArray[i + 0] - center_x;\n        const y = positionArray[i + 1] - center_y;\n        const z = positionArray[i + 2] - center_z;\n        if (x * x + y * y + z * z > limit) {\n          continue;\n        }\n        if (ignoreBackFace) {\n          if (\n            normalArray[i + 0] * direction_x +\n              normalArray[i + 1] * direction_y +\n              normalArray[i + 2] * direction_z <\n            0\n          ) {\n            continue;\n          }\n        }\n        const hasUpdated = this.setColor(i / 3);\n        if (hasUpdated) {\n          needsUpdate = true;\n        }\n      }\n      if (needsUpdate) {\n        geometry.attributes.color.needsUpdate = true;\n        geometry.colorsNeedUpdate = true;\n        return true;\n      }\n    }\n  }\n\n///////////////////////////\n  getPaintID(center) {\n    //window.geometryState = this;\n    const geometry = this.geometry;\n    const center_x = center.x,\n      center_y = center.y,\n      center_z = center.z;\n    const positionArray = geometry.attributes.position.array;\n    const length = positionArray.length;\n\n    var x = positionArray[0] - center_x;\n    var y = positionArray[1] - center_y;\n    var z = positionArray[2] - center_z;\n    var dist  = x * x + y * y + z * z\n    var i_min = 0\n    for (let i = 0+3; i < length; i += 3) {\n        x = positionArray[i + 0] - center_x;\n        y = positionArray[i + 1] - center_y;\n        z = positionArray[i + 2] - center_z;\n        const d = x * x + y * y + z * z\n        if (d < dist) {\n          i_min = i;\n          dist  = d;\n        }\n    }\n    const ids = this.getColorId(i_min / 3);\n    return ids;\n  }\n///////////////////////////\n\n  getCurrentParams() {\n    let area = 0;\n    const areas = Object.keys(this.geometryColors).map(colorId => {\n      const partArea = this.geometryColors[colorId]?.totalArea;\n      area += partArea;\n      return {\n        colorId,\n        area: partArea,\n      };\n    });\n    return {\n      area,\n      areas,\n    };\n  }\n}\n\nclass GeometryStateMap {\n  map = new WeakMap();\n  get(geometry) {\n    if (!this.map.has(geometry)) {\n      this.map.set(geometry, new GeometryState(geometry));\n    }\n    return this.map.get(geometry);\n  }\n}\nconst geometryStateMap = new GeometryStateMap();\nexport const getGeometryState = geometry => geometryStateMap.get(geometry);\n\nconst calcArea = (x1, y1, z1, x2, y2, z2, x3, y3, z3) => {\n  const a1 = x1 - x3;\n  const b1 = y1 - y3;\n  const c1 = z1 - z3;\n  const a2 = x2 - x3;\n  const b2 = y2 - y3;\n  const c2 = z2 - z3;\n  const p1 = b1 * c2 - b2 * c1;\n  const p2 = c1 * a2 - c2 * a1;\n  const p3 = a1 * b2 - a2 * b1;\n  return (p1 * p1 + p2 * p2 + p3 * p3) / 2;\n};\n","import { getGeometryState } from \"./geometryState\";\n\nconst getRay = ({ raymouse, camera }) => {\n  if (camera && camera.isPerspectiveCamera) {\n    return new THREE.Vector3()\n      .set(raymouse.x, raymouse.y, 0)\n      .unproject(camera)\n      .sub(camera.position)\n      .normalize();\n  } else {\n    console.error(\"Unsupported camera type.\");\n  }\n};\nconst raycaster = new THREE.Raycaster();\nconst _getIntersect = ({ raymouse, camera, meshes }) => {\n  raycaster.setFromCamera(raymouse, camera);\n  const intersects = raycaster.intersectObjects(meshes);\n  const intersect = intersects.find(\n    intersect => intersect.object.type === \"Mesh\"\n  );\n  return intersect;\n};\n\nexport const getIntersect = ({\n  x,\n  y,\n  camera,\n  meshes,\n  container,\n}) => {\n  const raymouse = new THREE.Vector2(\n    (x / container.clientWidth) * 2 - 1,\n    -(y / container.clientHeight) * 2 + 1\n  );\n  const intersect = _getIntersect({ raymouse, camera, meshes });\n  return {\n    intersect\n  };\n}\n\nexport const annotateBySphere = ({\n  x,\n  y,\n  camera,\n  meshes,\n  container,\n  radius,\n  ignoreBackFace,\n  color,\n}) => {\n  const raymouse = new THREE.Vector2(\n    (x / container.clientWidth) * 2 - 1,\n    -(y / container.clientHeight) * 2 + 1\n  );\n  const intersect = _getIntersect({ raymouse, camera, meshes });\n  if (!intersect) {\n    return {\n      intersect\n    }\n  }\n\n  const mesh = intersect.object;\n  const geometry = mesh.geometry;\n  // 高速化のため、逆行列をかけておく\n  const center = intersect.point\n    .clone()\n    .applyMatrix4(new THREE.Matrix4().getInverse(mesh.matrix));\n  const scale = mesh.scale.x; // scale.x, scale.y, scale.z are the same\n  const limit = (radius * radius) / (scale * scale);\n  const direction = getRay({ raymouse, camera });\n\n  const geometryState = getGeometryState(geometry);\n  geometryState.annotate({\n    center,\n    direction,\n    limit,\n    color,\n    ignoreBackFace,\n  });\n  return {\n    intersect\n  }\n};\n\n\n///////////////////////////////\nexport const getPaintID = ({\n  x,\n  y,\n  camera,\n  meshes,\n  container,\n}) => {\n  const raymouse = new THREE.Vector2(\n    (x / container.clientWidth) * 2 - 1,\n    -(y / container.clientHeight) * 2 + 1\n  );\n  const intersect = _getIntersect({ raymouse, camera, meshes });\n  if (!intersect) {\n    return {\n      intersect\n    }\n  }\n  const mesh = intersect.object;\n  const geometry = mesh.geometry;\n  // 高速化のため、逆行列をかけておく\n  const center = intersect.point\n    .clone()\n    .applyMatrix4(new THREE.Matrix4().getInverse(mesh.matrix));\n//  const scale = mesh.scale.x; // scale.x, scale.y, scale.z are the same\n//  const limit = (radius * radius) / (scale * scale);\n//  const direction = getRay({ raymouse, camera });\n  const geometryState = getGeometryState(geometry);\n  const ids = geometryState.getPaintID( center );\n  return ids;\n};\n///////////////////////////////\n\n\n\nexport const getCurrentParams = ({ meshes }) => {\n  let area = 0;\n  const areas = {};\n  meshes.forEach(mesh => {\n    const geometry = mesh.geometry;\n    if (!geometry.isBufferGeometry) {\n      return;\n    }\n    const geometryState = getGeometryState(geometry);\n    const result = geometryState.getCurrentParams();\n    area += result.area;\n    result.areas.forEach(o => {\n      areas[o.colorId] = (areas[o.colorId] || 0) + o.area;\n    });\n  });\n  return {\n    area,\n    areas,\n  };\n};\n\nexport const setColorOptions = (options, { meshes }) => {\n  meshes.forEach(mesh => {\n    const geometry = mesh.geometry;\n    if (!geometry.isBufferGeometry) {\n      return;\n    }\n    const geometryState = getGeometryState(geometry);\n    geometryState.setColorOptions(options);\n  });\n};\n\nexport const getChanges = ({ meshes }) => {\n  const response = {};\n  meshes.forEach(mesh => {\n    const geometry = mesh.geometry;\n    if (!geometry.isBufferGeometry) {\n      return;\n    }\n    const geometryState = getGeometryState(geometry);\n    const changes = geometryState.getChanges();\n    if(Object.keys(changes).length > 0) {\n      response[mesh.name] = changes;\n    }\n  });\n  return response;\n};\n\nexport const setAnnotation = ({ mesh, colorId, data }) => {\n  const geometry = mesh.geometry;\n  const geometryState = getGeometryState(geometry);\n  geometryState.setAnnotation(colorId, data);\n}","var util = {};\nimport { APP } from \"./APP\";\n\n/**\n * 有効な数値かどうかチェックする。文字列なら数値として有効かチェックする\n *\n * @example\n * isNumeric(1) // true\n * isNumeric(123.456) // true\n * isNumeric(0) // true\n * isNumeric(-123) // true\n * isNumeric(\"abc\") // false\n * isNumeric(\"123\") // true\n * isNumeric(\"-123\") // true\n *\n * @param  {string|number} n チェックする対象の値\n * @return {boolean}\n */\nutil.isNumeric = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n/**\n * マーカー名として有効かチェック\n * 英数字 [a-zA-Z0-9_-] またはスペースで構成される文字列かどうかチェックする\n *\n * @example\n * isMarkerName('abc') // true\n * isMarkerName('Marker Test 3') // true\n * isMarkerName('マーカー') // false\n *\n * @param  {string} str チェックする対象の文字列\n * @return {boolean}\n */\nutil.isMarkerName = function(string) {\n  return /^(?:[a-zA-Z0-9_-]| )+$/.test(string);\n};\n\nAPP.disposeNode = function(node){\n    if (node instanceof THREE.Mesh)\n    {\n        if (node.geometry)\n        {\n            node.geometry.dispose ();\n        }\n\n        if (node.material)\n        {\n            if (node.material instanceof THREE.MeshFaceMaterial)\n            {\n                $.each (node.material.materials, function (idx, mtrl)\n                {\n                    if (mtrl.map)               mtrl.map.dispose ();\n                    if (mtrl.lightMap)          mtrl.lightMap.dispose ();\n                    if (mtrl.bumpMap)           mtrl.bumpMap.dispose ();\n                    if (mtrl.normalMap)         mtrl.normalMap.dispose ();\n                    if (mtrl.specularMap)       mtrl.specularMap.dispose ();\n                    if (mtrl.envMap)            mtrl.envMap.dispose ();\n                    if (mtrl.alphaMap)          mtrl.alphaMap.dispose();\n                    if (mtrl.aoMap)             mtrl.aoMap.dispose();\n                    if (mtrl.displacementMap)   mtrl.displacementMap.dispose();\n                    if (mtrl.emissiveMap)       mtrl.emissiveMap.dispose();\n                    if (mtrl.gradientMap)       mtrl.gradientMap.dispose();\n                    if (mtrl.metalnessMap)      mtrl.metalnessMap.dispose();\n                    if (mtrl.roughnessMap)      mtrl.roughnessMap.dispose();\n\n                    mtrl.dispose ();    // disposes any programs associated with the material\n                });\n            }\n            else\n            {\n                if (node.material.map)              node.material.map.dispose ();\n                if (node.material.lightMap)         node.material.lightMap.dispose ();\n                if (node.material.bumpMap)          node.material.bumpMap.dispose ();\n                if (node.material.normalMap)        node.material.normalMap.dispose ();\n                if (node.material.specularMap)      node.material.specularMap.dispose ();\n                if (node.material.envMap)           node.material.envMap.dispose ();\n                if (node.material.alphaMap)         node.material.alphaMap.dispose();\n                if (node.material.aoMap)            node.material.aoMap.dispose();\n                if (node.material.displacementMap)  node.material.displacementMap.dispose();\n                if (node.material.emissiveMap)      node.material.emissiveMap.dispose();\n                if (node.material.gradientMap)      node.material.gradientMap.dispose();\n                if (node.material.metalnessMap)     node.material.metalnessMap.dispose();\n                if (node.material.roughnessMap)     node.material.roughnessMap.dispose();\n\n                node.material.dispose ();   // disposes any programs associated with the material\n            }\n        }\n    }\n}   // disposeNode\n\n\nAPP.disposeHierarchy = function(node, callback) {\n    for (var i = node.children.length - 1; i >= 0; i--)\n    {\n        var child = node.children[i];\n        disposeHierarchy (child, callback);\n        callback (child);\n    }\n}\n\n\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAzDA;AA2DA;AAEA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AChOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;AC5TA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;AC/PA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAHA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACnLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3DA;AACA;AA+DA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAKA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;ACzTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArDA;AACA;AAwDA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;;;;;;;;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AC3QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AApEA;AACA;AAwEA;AACA;AACA;AACA;AAEA;;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AADA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAtBA;AACA;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAvDA;AACA;AAyDA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAPA;AACA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAWA;AACA;AAEA;AAEA;AAGA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;ACfA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAVA;AACA;AAWA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAJA;AA3BA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAWA;AACA;AACA;AACA;AAYA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AA5QA;AACA;AA6QA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AARA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AADA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AADA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5KA;AAAA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;AAeA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnGA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}