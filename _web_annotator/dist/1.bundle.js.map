{"version":3,"file":"1.bundle.js","sources":["webpack:///./js/APP.js","webpack:///./js/ControlAnnotator.js","webpack:///./js/HandleBasement.js","webpack:///./js/HandleMarkers.js","webpack:///./js/HandleSkeletons.js","webpack:///./js/HandleSurfaces.js","webpack:///./js/MarkerTable.js","webpack:///./js/PaintTable.js","webpack:///./js/SurfaceTable.js","webpack:///./js/SyncPaint.js","webpack:///./js/csv.js","webpack:///./js/init.js","webpack:///./js/util.js","webpack:///util (ignored)","webpack:///util (ignored)?ca23","webpack:///buffer (ignored)","webpack:///crypto (ignored)","webpack:///ws (ignored)"],"sourcesContent":["export const APP = {};\r\nwindow.APP = APP;","import { APP } from \"./APP\";\r\n\r\n//\r\n// Shared\r\n//\r\nwindow.ChangeMode = function (mode) {\r\n\tswitch (mode) {\r\n\t\tcase \"view\":\r\n\t\t\tAPP.MarkerMode   = 0;\r\n\t\t\tAPP.SkeletonMode = 0;\r\n\t\t\tAPP.cursor.visible = false;\r\n\t\t\tswitchAnnotation(0);\r\n\t\t\tAPP.changeSurfaceObjectOpacity(-1);\r\n\t\t\tAPP.removeSkeletons();\r\n\t\t\tbreak;\r\n\t\tcase \"point\":\r\n\t\t\tAPP.MarkerMode   = 1;\r\n\t\t\tAPP.SkeletonMode = 0;\r\n\t\t\tAPP.cursor.visible = false;\r\n\t\t\tswitchAnnotation(0);\r\n\t\t\tAPP.changeSurfaceObjectOpacity(-1);\r\n\t\t\tAPP.removeSkeletons();\r\n\t\t\tbreak;\r\n\t\tcase \"paint\":\r\n\t\t\tAPP.MarkerMode   = 0;\r\n\t\t\tAPP.SkeletonMode = 0;\r\n\t\t\tAPP.cursor.visible = true;\r\n\t\t\tswitchAnnotation(1);\r\n\t\t\tAPP.changeSurfaceObjectOpacity(-1);\r\n\t\t\tAPP.removeSkeletons();\r\n\t\t\tbreak;\r\n\t\tcase \"skeleton\":\r\n\t\t\tAPP.MarkerMode   = 0;\r\n\t\t\tAPP.SkeletonMode = 1;\r\n\t\t\tAPP.cursor.visible = false;\r\n\t\t\tswitchAnnotation(0);\r\n\t\t\tAPP.changeSurfaceObjectOpacity(0);\r\n\t\t\tAPP.addSkeletons();\r\n\t\tbreak;\t\t\r\n\t\tdefault:\r\n    \t\tconsole.log(`Error. Mode ${mode} cannot be interpreted.`);\r\n\t\t}\r\n\t}\r\n//\r\n// app/index.jsで使っている\r\n//\r\nwindow.MarkerOffOn = function (ischecked) {\r\n\t\tif( ischecked == true ) {\r\n      \t\tAPP.MarkerOffOn = 1;\r\n   \t\t\t}\r\n\t\telse {\r\n\t\t\tAPP.MarkerOffOn = 0;\r\n\t\t\t}\r\n      }\r\n\r\n\r\nwindow.SaveImage = function (ischecked) {\r\n\tlet canvas = document.getElementById(\"myCanvas\").querySelector('canvas');\r\n\r\n\tlet link = document.createElement(\"a\");\r\n\tlink.href = canvas.toDataURL(\"image/png\");\r\n\tlink.download = \"Screenshot.png\";\r\n\tlink.click();\r\n\t}\r\n\r\n\r\n//\r\n// View\r\n//\r\nwindow.BackgroundWhiteBlack = function (ischecked) {\r\n\t\tif( ischecked == true ) {\r\n\t\t\tAPP.setBackGroundColor( 0x000000 );\r\n\t\t\tAPP.BackGroundColor = 'Black';\r\n\t\t\tAPP.setBoundingBoxColor( 0xffffff );\r\n   \t\t\t}\r\n\t\telse {\r\n\t\t    APP.setBackGroundColor( 0xffffff );\r\n      \t\tAPP.BackGroundColor = 'White';\r\n      \t\tAPP.setBoundingBoxColor( 0x000000 );\r\n\t\t\t}\r\n      }\r\nwindow.FrameOffOn =  function (ischecked) {\r\n\t\tif( ischecked == true ) {\r\n      \t\tAPP.addBoundingBox();\r\n   \t\t\t}\r\n\t\telse {\r\n\t\t\tAPP.removeBoundingBox();\r\n\t\t\t}\r\n      }\r\nwindow.DirLight = function (isnum) {\r\n\t\tAPP.directionalLight.intensity = isnum / 100;\r\n      }\r\n\r\nwindow.AmbLight = function (isnum) {\r\n\t\tAPP.ambientLight.intensity = isnum / 100;\r\n      }\r\n\r\nwindow.CenterXY = function () {\r\n\tAPP.camera.up.set(0,1,0);\r\n\tAPP.camera.position.set( APP.BoundingboxX/2.0, APP.BoundingboxY/2.0, APP.BoundingboxMax*3.0);\r\n\tAPP.camera.lookAt(APP.BoundingboxZ/2.0, APP.BoundingboxY/2.0, APP.BoundingboxX/2.0);\r\n\tAPP.controls.target.set( APP.BoundingboxX/2.0 , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\r\n\t// APP.renderer.render(APP.scene, APP.camera);\r\n\t}\r\n\r\nwindow.CenterYZ = function () {\r\n\tAPP.camera.up.set(0,0,1);\r\n\tAPP.camera.position.set( APP.BoundingboxMax*3.0  , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\r\n\tAPP.camera.lookAt(APP.BoundingboxZ/2.0, APP.BoundingboxY/2.0, APP.BoundingboxX/2.0);\r\n\tAPP.controls.target.set( APP.BoundingboxX/2.0 , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\r\n\t// APP.renderer.render(APP.scene, APP.camera);\r\n\t}\r\n\r\nwindow.CenterZX = function () {\r\n\tAPP.camera.up.set(1,0,0);\r\n\tAPP.camera.position.set( APP.BoundingboxX/2.0, APP.BoundingboxMax*3.0, APP.BoundingboxZ/2.0);\r\n\tAPP.camera.lookAt(APP.BoundingboxZ/2.0, APP.BoundingboxY/2.0, APP.BoundingboxX/2.0);\r\n\tAPP.controls.target.set( APP.BoundingboxX/2.0 , APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\r\n\t// APP.renderer.render(APP.scene, APP.camera);\r\n\t}\r\n\r\n\r\n","import { APP } from \"./APP\";\r\nimport { PaintTable } from \"./PaintTable\";\r\nimport _ from \"lodash\";\r\nimport { paintManager } from \"./SyncPaint\";\r\nimport { SurfaceTable } from \"./SurfaceTable\";\r\nimport { getSurfaceName } from \"./HandleSurfaces\";\r\nimport * as zlib from \"zlib\";\r\nimport {\r\n\tgetIntersect,\r\n\tannotateBySphere,\r\n\tgetCurrentParams,\r\n\tgetChanges,\r\n\tsetAnnotation\r\n} from \"three-annotator\"\r\n\r\nvar xratio = 0.6;\r\nvar yratio = 0.95;\r\nvar frustumSize = 1000;\r\n\r\nfunction animate() {\r\n\tAPP.renderer.render( APP.scene, APP.camera );\r\n\tAPP.controls.update();\r\n\trequestAnimationFrame( animate );\r\n};\r\n\r\n\r\nAPP.dragging = false;\r\nAPP.paint_mode = false;\r\nAPP.paint_on = true;\r\nAPP.paint_overwriteB = false;\r\n\r\n\r\n// ObtainWindowSize\r\nfunction onWindowResize() {\r\n //   var aspect = window.innerWidth / window.innerHeight;\r\n //   APP.camera.left   = - frustumSize * aspect / 2;\r\n //   APP.camera.right  =   frustumSize * aspect / 2;\r\n //   APP.camera.top    =   frustumSize / 2;\r\n //APP.camera.bottom = - frustumSize / 2;\r\n //APP.camera.updateProjectionMatrix();\r\n // APP.renderer.setSize( window.innerWidth * xratio, window.innerHeight * yratio);\r\n    \r\n\t//APP.renderer.setPixelRatio(window.devicePixelRatio);\r\n    \r\n\t    \r\n\t      // サイズを取得\r\n\tconst width = window.innerWidth;\r\n\tconst height = window.innerHeight;\r\n\r\n\t  // カメラのアスペクト比を正す\r\n\tAPP.camera.aspect = (width * xratio) / (height * yratio);\r\n\tAPP.camera.updateProjectionMatrix();\r\n\r\n\t  // レンダラーのサイズを調整する\r\n\tAPP.renderer.setPixelRatio(window.devicePixelRatio);\r\n\tAPP.renderer.setSize(width * xratio, height * yratio);\r\n    \r\n\t}\r\n\r\n\r\n// Draw bounding box\r\nAPP.addBoundingBox = function(){\r\n\r\n\tif ( APP.BackGroundColor == 'Black'){\r\n\t\t  var mat = new THREE.LineBasicMaterial( { color: 0xFFFFFF, linewidth: 2 } );\r\n\t\t  }\r\n\telse{\r\n\t\tvar mat = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } );\r\n\t\t}\r\n\r\n\tvar geometry = new THREE.BoxBufferGeometry( APP.BoundingboxX, APP.BoundingboxY, APP.BoundingboxZ );\r\n\tvar geo = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry( geometry )\r\n\r\n\tvar boundingbox = new THREE.LineSegments( geo, mat );\r\n\tboundingbox.name = 'BoundingBox';\r\n\tboundingbox.scale.set(1,1,1);\r\n\tAPP.scene.add(boundingbox);\r\n\tAPP.BoundingBox = 'On';\r\n\tboundingbox.translateX( APP.BoundingboxX / 2.0 );\r\n\tboundingbox.translateY( APP.BoundingboxY / 2.0 );\r\n\tboundingbox.translateZ( APP.BoundingboxZ / 2.0 );\r\n\t}\r\n\r\nAPP.removeBoundingBox = function(){\r\n\tvar obj = APP.scene.getObjectByName('BoundingBox');\r\n\tif ( obj != undefined ) {\r\n    \t\tAPP.scene.remove(obj);\r\n\t\t}\r\n\tAPP.BoundingBox = 'Off';\r\n\t}\r\n\r\nAPP.setBoundingBoxColor = function(objcolor){\r\n\tvar obj = APP.scene.getObjectByName('BoundingBox');\r\n\tif ( obj != undefined ) {\r\n    \tobj.material.color.setHex( objcolor );\r\n\t\t}\r\n\t}\r\n\r\n// Set background color\r\nAPP.setBackGroundColor = function( backcolor ){\r\n\t\tAPP.scene.background = new THREE.Color( backcolor );\r\n\t}\r\n\r\n// Operation on mouse click\r\nfunction clickPosition( event ) {\r\n\tonDragStart(event);\r\n\t// Location of mouse\r\n\tvar clientX = event.clientX;\r\n\tvar clientY = event.clientY;\r\n\r\n\t// Normalization of location\r\n\tvar mouse = new THREE.Vector2();\r\n\tmouse.x = ( ( clientX - APP.renderer.domElement.offsetLeft ) / APP.renderer.domElement.clientWidth ) * 2 - 1;\r\n\tmouse.y = - ( ( clientY - APP.renderer.domElement.offsetTop ) / APP.renderer.domElement.clientHeight ) * 2 + 1;\r\n\r\n\t// Raycasterインスタンス作成\r\n\tvar raycaster = new THREE.Raycaster();\r\n\t// 取得したX、Y座標でrayの位置を更新\r\n\traycaster.setFromCamera( mouse, APP.camera );\r\n\r\n\t// Indetify crossing objects.\r\n\tvar intersects = raycaster.intersectObjects( APP.scene.children );\r\n\t\r\n\t// Obtain crossing surface objects.\r\n\tvar intersected_surfaces = [];\r\n\tfor (let i = 0; i < intersects.length; i++) {\r\n\t\tvar name = intersects[i].object.name;\r\n\t\tif (/^\\d*$/.test(name) && name.length === 10) {\r\n\t\t\t\tintersected_surfaces.push(intersects[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t/*\r\n\tintersects.traverse(function(obj) {\r\n\t\tif (/^\\d*$/.test(obj.object.name) && obj.object.name.length === 10 ) {\r\n\t\t\tintersected_surfaces.push(intersects[i]);\r\n\t\t\t}\r\n\t\t})\r\n\t*/\r\n\r\n\t// Put a marker if in the marker mode (this should be moved to HandleMarker.js).\r\n\t// Show the ID if not.\r\n\tif (intersected_surfaces.length > 0) {\r\n\t\t// Get the most proximal one\r\n\t\tvar name = intersected_surfaces[ 0 ].object.name;\r\n\t\tconst target = document.getElementById(\"ClickedObjectID\");\r\n\t\ttarget.innerHTML = name;\r\n\r\n\t\tif (APP.MarkerMode == 1) {\r\n\t\t\tvar x = intersected_surfaces[ 0 ].point.x;\r\n\t\t\tvar y = intersected_surfaces[ 0 ].point.y;\r\n\t\t\tvar z = intersected_surfaces[ 0 ].point.z;\r\n\r\n\t\t\t//Append Jsontable\r\n\t\t\tvar markerName = APP.MarkerPrefix + String(APP.MarkerSuffix);\r\n\r\n\t\t\tAPP.addMarker({\r\n\t\t\t\tact: 1,\r\n\t\t\t\tname: markerName,\r\n\t\t\t\tparentid: name,\r\n\t\t\t\tradius: APP.MarkerRadius,\r\n\t\t\t\tr: APP.MarkerR,\r\n\t\t\t\tg: APP.MarkerG,\r\n\t\t\t\tb: APP.MarkerB,\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y,\r\n\t\t\t\tz: z\r\n\t\t\t});\r\n\t\t}\r\n\t}else{\r\n\t\tconst target = document.getElementById(\"ClickedObjectID\");\r\n\t\ttarget.innerHTML = \"Background\";\r\n\t}\r\n}\r\n\r\n\r\nvar onDragStart = (event) => {\r\n  APP.dragging = true;\r\n\tannotate(event);\r\n}\r\n\r\nvar onDragEnd = (event) => {\r\n\tAPP.dragging = false;\r\n}\r\n\r\nvar annotate = (event) => {\r\n  if (!APP.dragging) {\r\n\tconst { intersect } = getIntersect({\r\n\t\tx: event.offsetX,\r\n\t\ty: event.offsetY,\r\n\t\tcamera: APP.camera,\r\n\t\tmeshes: APP.getMeshes(),\r\n\t\tcontainer: APP.renderer.domElement,\r\n\t})\r\n\tupdateCursor(intersect && intersect.point);\r\n\treturn;\r\n  };\r\n  if (!APP.paint_mode) return;\r\n  const { intersect } = annotateBySphere({\r\n\t\tx: event.offsetX,\r\n\t\ty: event.offsetY,\r\n\t\tcamera: APP.camera,\r\n\t\tmeshes: APP.getMeshes(),\r\n\t\tcontainer: APP.renderer.domElement,\r\n\t\tradius: getCursorRadius(APP.AnnotatorRadius),\r\n\t\tignoreBackFace: null,\r\n  });\r\n  updateCursor(intersect && intersect.point);\r\n  updateMetricsOnPaintTable()\r\n  syncAnnotation();\r\n};\r\n\r\n\r\nconst compress = paintData => paintData && zlib.gzipSync(Buffer.from(paintData)).buffer;\r\nconst decompress = compressedData => compressedData && new Uint8Array(zlib.gunzipSync(Buffer.from(compressedData)).buffer);\r\n\r\nconst syncAnnotation = _.debounce(() => {\r\n\tconst changes = getChanges({meshes: APP.getMeshes()});\r\n\tif(Object.keys(changes).length > 0) {\r\n\t\tfor(const objectChanges of Object.values(changes)) {\r\n\t\t\tfor(const colorChanges of Object.values(objectChanges)) {\r\n\t\t\t\tcolorChanges.painted = compress(colorChanges.painted);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpaintManager.update({changes})\r\n\t}\r\n}, 1000, { maxWait: 1000 });\r\n\r\npaintManager.emitter.on(\"update\", data => {\r\n\tif(data.room_id !== \"list\") {\r\n\t\tconsole.log(data.room_id);\r\n\t\tconst [surfaceId, colorId] = data.room_id.split(\"-\");\r\n\t\tconst mesh = APP.getMeshes().find(mesh => mesh.name === surfaceId);\r\n\t\tif(!mesh) {\r\n\t\t\tconsole.error(\"mesh not found\")\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsetAnnotation({ mesh, colorId, data: {\r\n\t\t\t...data,\r\n\t\t\tpainted: decompress(data.painted),\r\n\t\t}})\r\n\t\tupdateMetricsOnPaintTable();\r\n\t}\r\n})\r\n\r\nconst getCursorRadius = annotatorRadius => (annotatorRadius || 0.3);\r\n\r\nconst updateCursor = position => {\r\n\tif (APP.cursor.visible === false) {\r\n\t\treturn;\r\n\t}\r\n\tconst radius = getCursorRadius(APP.AnnotatorRadius);\r\n\tconst cursor = APP.cursor;\r\n\tif (position) {\r\n\t\tcursor.position.copy(position);\r\n\t\tconst zoom = radius;\r\n\t\tcursor.scale.set(zoom, zoom, zoom);\r\n\t\tcursor.material.opacity = 0.3;\r\n\t} else {\r\n\t\tcursor.material.opacity = 0;\r\n\t}\r\n}\r\n\r\nexport const updateMetricsOnPaintTable = () => {\r\n\tconst activeSurfaces = new Set(SurfaceTable.getData()\r\n\t\t.filter(row => row.act)\r\n\t\t.map(row => getSurfaceName(row.id))\r\n\t);\r\n\tconst meshes = APP.getMeshes().filter(mesh => activeSurfaces.has(mesh.name));\r\n\tconst params = getCurrentParams({ meshes });\r\n\tconst areas = params.areas;\r\n\tconst newRows = PaintTable.getData(\"active\").map((item = {}) => {\r\n\t\treturn {\r\n\t\t\t...item,\r\n\t\t\tarea: areas[item.id]\r\n\t\t}\r\n\t})\r\n\tPaintTable.updateData(newRows);\r\n};\r\n\r\n\r\nAPP.getMeshes = () => {\r\n\treturn APP.scene.children.filter(object => object.type === \"Mesh\" && object.geometry.isBufferGeometry && !object.isCursor);\r\n}\r\n\r\n\r\nexport function launchAnnotator() {\r\n\r\n\t// Renderer\r\n\tvar container = document.getElementById('myCanvas');\r\n\tAPP.renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );\r\n\tAPP.renderer.setSize(window.innerWidth * xratio, window.innerHeight * yratio);\r\n\tcontainer.appendChild( APP.renderer.domElement );\r\n\r\n\t// Initilize camera\r\n\tAPP.camera = new THREE.PerspectiveCamera();\r\n\r\n\t// Scene\r\n\tAPP.scene = new THREE.Scene();\r\n\tAPP.scene.add( APP.camera );\r\n\r\n\t// Background Color\r\n\tAPP.scene.background = new THREE.Color( 0xffffff );\r\n\tAPP.BackGroundColor == 'White';\r\n\r\n\t// Light\r\n\tAPP.directionalLight = new THREE.DirectionalLight(0xffffff);\r\n\tAPP.directionalLight.position.set(1, 1, 1);\r\n\tAPP.directionalLight.intensity = 0.8;\r\n\tAPP.camera.add( APP.directionalLight );\r\n\tAPP.ambientLight = new THREE.AmbientLight( 0xffffff );\r\n\tAPP.ambientLight.intensity = 0.5;\r\n\tAPP.camera.add( APP.ambientLight );\r\n\r\n\tvar min = 0 ;\r\n\tvar max = 255 ;\r\n\r\n\t// Controlsを用意\r\n\tAPP.controls = new THREE.TrackballControls( APP.camera, APP.renderer.domElement );\r\n\tAPP.controls.rotateSpeed = 10;\r\n    APP.controls.staticMoving = false;\r\n\tAPP.controls.dynamicDampingFactor = 1.0; // staticMoving = false のときの減衰量\r\n\tanimate();\r\n\r\n\t// Response to mouse click\r\n\tAPP.renderer.domElement.addEventListener( 'mousedown', clickPosition, false );\r\n\tAPP.renderer.domElement.addEventListener('mouseup', onDragEnd, false);\r\n\tAPP.renderer.domElement.addEventListener('onmousemove', annotate, false);\r\n\tAPP.renderer.domElement.onmousemove = annotate;\r\n\r\n\t// Paint\r\n\t// Cursor\r\n\tvar geometry = new THREE.SphereBufferGeometry( 1, 32, 32 );\r\n\tvar material = new THREE.MeshLambertMaterial( {color: 0xffffff, opacity: 0, transparent: true, depthWrite: false} );\r\n\tvar cursor = new THREE.Mesh( geometry, material );\r\n\tcursor.isCursor = true;\r\n\tcursor.name = 'cursor';\r\n\tAPP.cursor = cursor;\r\n\tAPP.cursor.visible = false;\r\n\tAPP.scene.add( cursor );\r\n\r\n    // Marker\r\n\tAPP.MarkerMode = 0;\r\n\tAPP.MarkerR = 255;\r\n\tAPP.MarkerG = 0;\r\n\tAPP.MarkerB = 0;\r\n\tAPP.MarkerPrefix = \"Marker\";\r\n\tAPP.MarkerSuffix = 0;\r\n\tAPP.MarkerRadius = 0.1;\r\n\tAPP.MarkerID     = 1;\r\n\r\n\t// Surface opacity\r\n\tAPP.surface_opacity          = 1.0;\r\n\tAPP.surface_opacity_reserved = 0.5;\r\n\r\n\t// Skeleton\r\n\tAPP.SkeletonMode = 0;\r\n\r\n\r\n    // Add sphere tmp\r\n    // var geometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n    // var material = new THREE.MeshBasicMaterial({color: 0x6699FF});\r\n    // var sphere = new THREE.Mesh(geometry, material);\r\n    // sphere.position.set(0, 0, 0);\r\n    // APP.scene.add(sphere);\r\n    // Add sphere tmp\r\n\r\n\r\n\t//Boundingbox\r\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/surface/VolumeDescription.json\";\r\n\t$.getJSON(call_url).done(function(data) {\r\n\t\t//data_parsed = JSON.parse(data);\r\n\t\tconsole.log(data)\r\n        APP.BoundingboxX = data.boundingbox_um.x;\r\n\t\tAPP.BoundingboxY = data.boundingbox_um.y;\r\n\t\tAPP.BoundingboxZ = data.boundingbox_um.z;\r\n\t\tAPP.BoundingboxMax = Math.max(APP.BoundingboxX, APP.BoundingboxY, APP.BoundingboxZ);\r\n\t\tconsole.log('APP.BoundingboxMax: ', APP.BoundingboxMax)\r\n\t\t\r\n\t\t\r\n\t\t// Add sphere tmp2\r\n\t\t// var geometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n\t\t// var material = new THREE.MeshBasicMaterial({color: 0xFF9955});\r\n\t\t// var sphere = new THREE.Mesh(geometry, material);\r\n\t\t// sphere.position.set(APP.BoundingboxX/2.0, APP.BoundingboxY/2.0, APP.BoundingboxZ/2.0);\r\n\t\t// APP.scene.add(sphere);\r\n\t\t// Add sphere tmp2\r\n\r\n\t\t\r\n\t\twindow.CenterXY()\r\n    });\r\n}\r\n\r\n\r\nwindow.addEventListener( 'resize', onWindowResize, false );\r\n\r\n\r\n","//\r\n//\r\n//\r\n//\r\n//\r\nimport { APP } from \"./APP\";\r\nimport { parseCSV, csvFormatter } from \"./csv\";\r\nimport { MarkerTable } from \"./MarkerTable\";\r\n\r\n/**\r\n * マーカーを追加する\r\n *\r\n * @param {Object} markerData CSVで読み込まれたプロパティを持つオブジェクト。以下のプロパティが有効\r\n *   - act      : {number} 例: 1\r\n *   - name     : {string} 例: \"Marker1\"\r\n *   - parentid : {number} 例: 3036\r\n *   - radius   : {number} 例: 2.8\r\n *   - r        : {number} 例: 255\r\n *   - g        : {number} 例: 30\r\n *   - b        : {number} 例: 100\r\n *   - x        : {number} 例: 9.076891761740626\r\n *   - y        : {number} 例: 10.850928915374125\r\n *   - z        : {number} 例: 252.16774396931498\r\n *\r\n * @param {bool} [isImportFromFile=false] ファイルからの読み込みかどうか。\r\n *   ファイルからの読み込み時はMarkerがOFFでもMarkerTableに追加する\r\n * @return {bool} マーカーを追加したらtrueが返る\r\n */\r\n\r\nAPP.addMarker = function(markerData, isImportFromFile) {\r\n  var markerData_act = Number(markerData.act);\r\n  var markerData_name = String(markerData.name);\r\n  var markerData_parentid = Number(markerData.parentid);\r\n  var markerData_radius = Number(markerData.radius);\r\n  var markerData_r = Number(markerData.r);\r\n  var markerData_g = Number(markerData.g);\r\n  var markerData_b = Number(markerData.b);\r\n  var markerData_x = Number(markerData.x);\r\n  var markerData_y = Number(markerData.y);\r\n  var markerData_z = Number(markerData.z);\r\n\r\n  // CSVファイルからの読み込み時はMarkerがOFFでも描画する(要確認)\r\n  if (APP.MarkerMode == 1 || isImportFromFile) {\r\n    var color = rgb2hex([markerData_r, markerData_g, markerData_b]);\r\n\r\n    // Add sphere\r\n    var geometry = new THREE.SphereGeometry(1);\r\n    var material = new THREE.MeshBasicMaterial({ color: color });\r\n    var sphere = new THREE.Mesh(geometry, material);\r\n\r\n    sphere.scale.set(markerData_radius, markerData_radius, markerData_radius);\r\n    sphere.position.set(markerData_x, markerData_y, markerData_z);\r\n    sphere.name = 'm' + APP.MarkerID.toString();\r\n    APP.scene.add(sphere);\r\n\r\n    var NewMarker = {\r\n      act: markerData_act,\r\n      id: APP.MarkerID,\r\n      name: markerData_name,\r\n      parentid: markerData_parentid,\r\n      radius: markerData_radius,\r\n      r: markerData_r,\r\n      g: markerData_g,\r\n      b: markerData_b,\r\n      x: markerData_x,\r\n      y: markerData_y,\r\n      z: markerData_z\r\n    };\r\n    MarkerTable.addData(NewMarker);  // Change database MarkerTable (setData)\r\n    updateMarkerId();\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n\r\nfunction rgb2hex ( rgb ) {\r\n\treturn \"#\" + rgb.map( function ( value ) {\r\n\t\treturn ( \"0\" + value.toString( 16 ) ).slice( -2 ) ;\r\n\t} ).join( \"\" ) ;\r\n}\r\n\r\n/**\r\n * MarkerIDを更新する\r\n */\r\nfunction updateMarkerId() {\r\n  APP.MarkerSuffix = APP.MarkerSuffix + 1;\r\n  APP.MarkerID = APP.MarkerID + 1;\r\n  $('#SetSuffixNum').val(APP.MarkerSuffix); // Change suffix for index.html\r\n};\r\n\r\n/**\r\n * マーカーを描画する\r\n *\r\n * @example\r\n * renderMarker({\r\n *   \"act\": 1,\r\n *   \"name\": \"test1\",\r\n *   \"parentid\": 3000,\r\n *   \"radius\": 2,\r\n *   \"r\": 100,\r\n *   \"g\": 0,\r\n *   \"b\": 0,\r\n *   \"x\": 100,\r\n *   \"y\": 200,\r\n *   \"z\": 200\r\n * })\r\n *\r\n * @param {Object} markerData CSVで読み込まれたプロパティを持つオブジェクト。addMarkerの引数と同じ\r\n */\r\nAPP.renderMarker = function(markerData) {\r\n  var obj = APP.scene.getObjectByName(Number(markerData.parentid));\r\n  if (obj == null) {\r\n    return false;\r\n  }\r\n  return APP.addMarker(markerData, true);\r\n};\r\n\r\n\r\n// Change the color of the stl object specified by a name after generation.\r\nAPP.changeMarkerRadius = function(id, r){\r\n\tvar name = 'm'+ id.toString();\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tconsole.log(obj);\r\n\tif ( obj != undefined ) {\r\n    \t\tobj.scale.set(r,r,r);\r\n\t\t}\r\n\t}\r\n\r\n// Change the color of the stl object specified by a name after generation.\r\nAPP.changeMarkerColor = function(id, objcolor){\r\n\tvar name = 'm'+ id.toString();\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n    \t\tobj.material.color.setHex( objcolor );\r\n\t\t}\r\n\t}\r\n\r\n// Remove a stl object by a name after generation.\r\nAPP.removeMarker = function(id){\r\n\t// Remove from scene\r\n\tvar name = 'm'+ id.toString();\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n    APP.scene.remove(obj);\r\n\t}\r\n}\r\n\r\n\r\n","//\r\n//\r\n//\r\n//\r\n//\r\nimport { APP } from \"./APP\";\r\nimport { parseCSV, csvFormatter } from \"./csv\";\r\nimport * as hdf5 from 'jsfive';\r\n\r\n// Change the opacity of all surface objects\r\n\r\nAPP.addSkeletons = function() {\r\n\tAPP.scene.traverse(function(obj) {\r\n\t\tif ( (obj instanceof THREE.Mesh === true) && (obj.visible === true) && (obj.name.length === 10) ) {\r\n\t\t\tvar id  = obj.name - 0;\r\n\t\t\tvar col = obj.material.color;\r\n\t\t\tAPP.addSkeletonObject(id, col)\r\n\t\t}\r\n\t});\r\n}\r\n\r\nAPP.removeSkeletons = function() {\r\n\tAPP.scene.traverse(function(obj) {\r\n\t\tif ( obj.name.match(/line/) ) {\r\n\t\t\tobj.visible = false;\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n// Add stl objects and a name\r\nAPP.addSkeletonObject = function(id, col) {\r\n\r\n\tif (APP.SkeletonMode == 0){\r\n\t\treturn false;\r\n\t\t}\r\n\r\n\tconst target_url = location.protocol+\"//\"+location.host+\"/skeleton/whole/\" + ( '0000000000' + id ).slice( -10 ) + \".hdf5\";\r\n\tconst filename   = ( '0000000000' + id ).slice( -10 ) + \".hdf5\";\r\n\tconst name       = 'line' + ( '0000000000' + id ).slice( -10 );\r\n\t\r\n\t// Revive it if already exists.\r\n\t// console.log('Name: ', name)\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n\t\t// console.log('Obj: ', obj)\r\n\t\tobj.visible = true;\r\n\t\treturn true;\r\n\t\t}\r\n\t\r\n\t//\r\n\tfetch(target_url)\r\n\t  .then(function(response) {\r\n\t    return response.arrayBuffer() \r\n\t  })\r\n\t  .then(function(buffer) {\r\n\t    //\r\n\t    //\r\n\t    var f = new hdf5.File(buffer, filename);\r\n\t    let g1 = f.get('vertices');\r\n\t    let g2 = f.get('edges');\r\n\t    var data_vertices = g1.value;\r\n\t    var data_edges    = g2.value;\r\n\t    \r\n\t    data_vertices = splitArray(data_vertices, 3);\r\n\t    data_edges    = splitArray(data_edges, 2);\r\n\t    \r\n\t    \r\n\t\tvar i1 = undefined;\r\n\t\tvar i2 = undefined;\r\n\t\tvar v1 = undefined;\r\n\t\tvar v2 = undefined;\r\n\t\t// console.log(data_vertices)\r\n\t\t// console.log('Length vertices: ' + data_vertices.length);\r\n\t\t// console.log('Length edges   : ' + data_edges.length);\r\n\t\tif (isNaN(data_vertices[0][0]) == true) {\r\n\t\t\t// console.log(data_vertices);\r\n\t\t\tconsole.log('No morphological data.');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial({\r\n\t\t\tcolor: col,  //0x000000\r\n\t\t\tlinewidth: 3,\r\n\t\t\tfog:true\r\n\t\t});\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tfor(var i=0;i< data_edges.length;i++){\r\n\t\t\ti1 = data_edges[i][0];\r\n\t\t\ti2 = data_edges[i][1];\r\n\r\n\t\t\t// console.log('Vertices ID: ', i1, i2 );\r\n\r\n\t\t\tv1 = new THREE.Vector3( data_vertices[i1][0], data_vertices[i1][1], data_vertices[i1][2]);\r\n\t\t\tv2 = new THREE.Vector3( data_vertices[i2][0], data_vertices[i2][1], data_vertices[i2][2]);\r\n\t\t\tgeometry.vertices.push(v1, v2);\r\n\t\t\t}\r\n\t\tvar line = new THREE.LineSegments( geometry, material );   \r\n\t\t\r\n\t\t\r\n\t\tline.name = name;\r\n\t\t// console.log(line.name);\r\n\t\tAPP.scene.add( line );\t    \r\n\t    //\r\n\t    //\r\n\t    //\r\n\t  });\r\n\t}\r\n\r\n\r\n// Change the color of a skeleton object specified by a name.\r\nAPP.changeSkeletonObjectColor = function(id, col) {\r\n\tname = 'line' + ( '0000000000' + id ).slice( -10 );\r\n\tvar obj = APP.scene.getObjectByName(name_centerline);\r\n\tif ( obj != undefined ) {\r\n\t\tobj.material.color.setHex( col );\r\n\t\t}\r\n\t}\r\n\r\n\r\n// Remove a stl object by the name.\r\nAPP.removeSkeletonObject = function(id) {\r\n\tname = 'line' + ( '0000000000' + id ).slice( -10 );\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n\t\t// APP.scene.remove(obj);\r\n\t\tobj.visible = false;\r\n\t\t}\r\n\t}\r\n\r\n\r\nfunction splitArray(array, part) {\r\n    var tmp = [];\r\n    for(var i = 0; i < array.length; i += part) {\r\n        tmp.push(array.slice(i, i + part));\r\n    }\r\n    return tmp;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","//\r\n//\r\n//\r\n//\r\n//\r\nimport { APP } from \"./APP\";\r\nimport { parseCSV, csvFormatter } from \"./csv\";\r\nimport { updateColorOptionsOnAnnotator } from \"./PaintTable\";\r\nimport { paintManager } from \"./SyncPaint\";\r\n\r\nexport const getSurfaceName = id => {\r\n\treturn ( '0000000000' + id ).slice( -10 );\r\n}\r\n\r\n// Add surface objects and a name\r\nAPP.addSurfaceObject = function(id, col) {\r\n\r\n\tconst name =  getSurfaceName(id);\r\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/ws/surface?id=\";\r\n\tconst target_url = location.protocol+\"//\"+location.host+\"/surface/whole/\" + name + \".stl\";\r\n\r\n\t// Revive it if already exists.\r\n\t// console.log('Name: ', name)\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n\t\t// console.log('Obj: ', obj)\r\n\t\tobj.visible = true;\r\n\t\tpaintManager.addSurface(name);\r\n\t\treturn true;\r\n\t\t}\r\n\r\n\t// Request the surface mesh generation to the server if it does not exist.\r\n\tvar xhr = new XMLHttpRequest();\r\n\txhr.open(\"HEAD\", target_url, false);  //同期モード\r\n\txhr.send(null);\r\n\tif(xhr.status == 404) {\r\n\t\t\tvar req = new XMLHttpRequest();\r\n\t\t\treq.open(\"get\", call_url+id, false);\r\n\t\t\treq.send(null);\r\n\t\t\tif (req.responseText == \"False\") {\r\n\t\t\t\talert(\"No surface.\");\r\n\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t}\r\n\t// console.log('Mesh prepared.');\r\n\r\n\t// Load the stl file then generate mesh object.\r\n\tvar loader = new THREE.STLLoader();\r\n\tloader.load(target_url, function(bufferGeometry) {\r\n\t  if (bufferGeometry.isBufferGeometry) {\r\n\t\t  bufferGeometry.attributes.color = bufferGeometry.attributes.color || bufferGeometry.attributes.position.clone();\r\n\t\t  bufferGeometry.attributes.color.array.fill(1);\r\n\t\t  bufferGeometry.attributes.color.needsUpdate = true;\r\n\t\t  bufferGeometry.colorsNeedUpdate = true;\r\n\t  }\r\n\t  // console.log('Stl loaded.');\r\n\t  const meshMaterial = new THREE.MeshPhongMaterial({\r\n\t\t  color: col,\r\n\t\t  specular: 0x776666,\r\n\t\t  shininess: 0.2,\r\n\t\t  vertexColors: THREE.FaceColors,\r\n\t\t  transparent: true,\r\n\t\t  opacity: APP.surface_opacity,\r\n\t\t  side: THREE.DoubleSide\r\n\t  }) // APP.surface_opacity\r\n\t  var mesh = new THREE.Mesh(bufferGeometry, meshMaterial);\r\n      mesh.name = name;\r\n      mesh.scale.set(1, 1, 1);\r\n      // mesh.material.side = THREE.DoubleSide;\r\n      APP.scene.add(mesh);\r\n\r\n\t  // console.log(mesh.name);\r\n\r\n\t  updateColorOptionsOnAnnotator();\r\n\t  paintManager.addSurface(name);\r\n\t});\r\n}\r\n\r\n// Change the opacity of all surface objects\r\n\r\nAPP.changeSurfaceObjectOpacity = function(opacity) {\r\n\t// console.log('Input opacity: ', opacity)\r\n\tif ( opacity == -1 ){\r\n\t\tAPP.surface_opacity = 1;\r\n\t} else if (opacity == 0) {\r\n\t\tAPP.surface_opacity = APP.surface_opacity_reserved;\r\n\t} else {\r\n\t\tAPP.surface_opacity = opacity;\r\n\t\tAPP.surface_opacity_reserved = opacity;\r\n\t};\r\n\r\n\tAPP.scene.traverse(function(obj) {\r\n\t\tif (obj instanceof THREE.Mesh === true && /^\\d*$/.test(obj.name) && obj.name.length === 10 ) {\r\n\t\t\tobj.material.opacity = APP.surface_opacity;\r\n\t\t\t}\r\n\t\t// console.log('Obj name:', obj.name );\r\n\t\t});\r\n}\r\n\r\n\r\n// Change the color of a surface object specified by the name.\r\nAPP.changeSurfaceObjectColor = function(id, objcolor) {\r\n\tconst name =  getSurfaceName(id);\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n    \t\tobj.material.color.setHex( objcolor );\r\n\t\t}\r\n\t}\r\n\r\n\r\n// Remove a stl object by a name after generation.\r\nAPP.removeSurfaceObject = function(id) {\r\n\tconst name =  getSurfaceName(id);\r\n\tvar obj = APP.scene.getObjectByName(name);\r\n\tif ( obj != undefined ) {\r\n\t\t// APP.scene.remove(obj);\r\n\t\tobj.visible = false;\r\n\t\t}\r\n\t\tpaintManager.removeSurface(name);\r\n\t}\r\n\r\n\r\n\r\n","import { APP } from \"./APP\";\r\nimport { parseCSV, csvFormatter } from \"./csv\";\r\nimport * as Tabulator from \"tabulator-tables\";\r\n\r\nexport const MarkerTable = new Tabulator(\"#MarkerTable\", {\r\n\tlayout:\"fitColumns\",      //fit columns to width of table\r\n\tautoResize:true,\r\n\tresponsiveLayout:\"hide\",  //hide columns that dont fit on the table\r\n\ttooltips:true,            //show tool tips on cells\r\n\taddRowPos:\"top\",          //when adding a new row, add it to the top of the table\r\n\thistory:true,             //allow undo and redo actions on the table\r\n\tpagination:\"local\",       //paginate the data\r\n\tpaginationSize:10,         //allow 7 rows per page of data\r\n\tresizableRows:true,       //allow row order to be changed\r\n\tinitialSort:[             //set the initial sort order of the data\r\n\t\t{column:\"id\", dir:\"dsc\"},\r\n\t],\r\n\tcolumns:[                 //define the table columns\r\n    // ActやX,Y,Zはダウンロード時に除外されないよう定義しておく。ただしカラムvisible: falseにして非表示にする\r\n    {title:\"Act\", field: \"act\", download: true, visible: false},\r\n\t\t{title:\"Delete\", formatter:\"buttonCross\", width: 73, hozAlign:\"center\", editor:\"tickCross\", editable: onDeleteCheck, download: false},\r\n\t\t{title:\"ID\", field:\"id\", width: 40},\r\n\r\n    // マーカー名を入力する時に日本語などASCII外が入力されないようにする\r\n    // 入力されるとCSVファイルダウンロード→インポートを通して文字化けが発生するため、[ a-zA-Z0-9_-] のみ使用可能とする\r\n\t\t{title:\"Name\", field:\"name\", width: 70, editor:\"input\", validator: function(cell, value, parameters) {\r\n      return util.isMarkerName(value);\r\n    }},\r\n\r\n\t\t{title:\"Parent ID\", field:\"parentid\", width: 70},\r\n\t\t{title:\"Radius\", field:\"radius\", width: 60, hozAlign:\"right\", editor:\"number\",editorParams:{min:0.01, max:1, step:0.01}},\r\n\t\t{title:\"R\", field:\"r\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\r\n\t\t{title:\"G\", field:\"g\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\r\n\t\t{title:\"B\", field:\"b\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\r\n    {title:\"X\", field:\"x\", download: true, visible: false},\r\n    {title:\"Y\", field:\"y\", download: true, visible: false},\r\n    {title:\"Z\", field:\"z\", download: true, visible: false}\r\n\t],\r\n\r\n  // セルが編集されたとき\r\n  cellEdited: function(cell) {\r\n    // 渡ってくるパラメータcellについて: http://tabulator.info/docs/4.1/components#component-cell\r\n    // 編集後の値\r\n    var cellValue = cell.getValue();\r\n    // 編集前の値\r\n    var cellOldValue = cell.getOldValue();\r\n    // 編集対象のセルがある列\r\n    var row = cell.getRow();\r\n    var act = row.getData().act;\r\n    var id  = row.getData().id;\r\n    var radius  = row.getData().radius;\r\n    var r   = row.getData().r;\r\n    var g   = row.getData().g;\r\n    var b   = row.getData().b;\r\n    var columnField = cell.getColumn().getField();\r\n\r\n    if (columnField == 'radius') {\r\n      APP.changeMarkerRadius(id, radius);\r\n    }\r\n\r\n    if (columnField == 'r' || columnField == 'g' || columnField == 'b') {\r\n      APP.changeMarkerColor(id, r*256*256+g*256+b*1);\r\n    }\r\n   }\r\n});\r\n\r\n\r\n// 「Import CSV」ボタンを押したとき\r\n$('#import-csv-marker-table').on('change', onImportCSVFileSelect);\r\n\r\n// 「Clear」ボタンを押したら3Dマーカーをクリアする\r\n$('#clear-marker-table').on('click', function(event) {\r\n  clearMarkerTable();\r\n  return false;\r\n});\r\n\r\n// 「Download CSV」ボタンを押したとき\r\n$('#save-marker-table-csv').on('click', function(event) {\r\n  downloadMarkerTableAsCSV();\r\n  return false;\r\n});\r\n\r\n\r\n// Deleteのチェックが押されたとき\r\nfunction onDeleteCheck(cell) {\r\n  var data = cell.getRow().getData();\r\n  APP.removeMarker(data.id);\r\n  cell.getRow().delete();\r\n}\r\n\r\n// 「Import CSV」ボタンが押されてファイルを選択したとき\r\nfunction onImportCSVFileSelect(event) {\r\n  var file = event.originalEvent.target.files[0];\r\n\r\n  var reader = new FileReader();\r\n  reader.onload = function(e) {\r\n    var csvFileContent = e.target.result;\r\n    var parsedData = parseCSV(csvFileContent);\r\n\r\n    // 1行目のタイトルを除外\r\n    parsedData.shift();\r\n    // タイトルフィールドを変換\r\n    var markers = replaceColumnTitle(ObjMarkerTable, parsedData);\r\n\r\n    // 同じ座標のためスキップした数\r\n    var sameCoordinatesCount = 0;\r\n    // Parent ID のオブジェクトが非表示のためスキップした数\r\n    var parentNotVisibleCount = 0;\r\n\r\n    markers.forEach(function(markerData) {\r\n      if (!validateMarkerDataType(markerData)) {\r\n        // 不正な値があったらスキップ\r\n        console.error(\"Invalid marker data\", markerData);\r\n      } else if (!validateMarkerDataXYZ(markerData)) {\r\n        // すでに同じ座標で定義済みだったらスキップ\r\n        console.warn(\"Skipped: The loaded marker has been defined as same coordinates.\", markerData);\r\n        sameCoordinatesCount++;\r\n      } else {\r\n        var isAdded = APP.renderMarker(markerData);\r\n        if (!isAdded) {\r\n          // Parent ID のオブジェクトが非表示だったらエラーを出す\r\n          console.warn(\"Skipped: The loaded marker's parent object has not visible.\", markerData);\r\n          parentNotVisibleCount++;\r\n        }\r\n      }\r\n    });\r\n\r\n    var errorMsg = [];\r\n    if (sameCoordinatesCount) {\r\n      errorMsg.push(sameCoordinatesCount + \" Skipped: The loaded marker has been defined as same coordinates.\");\r\n    }\r\n    if (parentNotVisibleCount) {\r\n      errorMsg.push(parentNotVisibleCount + \" Skipped: The loaded marker's parent object has not visible.\");\r\n    }\r\n    if (errorMsg.length) {\r\n      // スキップしたとき毎回アラートを出すとアラート数が増えすぎるのでまとめて通知する\r\n      alert(errorMsg.join(\"\\n\"));\r\n    }\r\n\r\n    // 選択したファイル情報をクリア。これをしないと同じファイルを再度読み込めない\r\n    $('#import-csv-marker-table').val('');\r\n  };\r\n  reader.readAsText(file);\r\n}\r\n\r\n/**\r\n * MarkerTableが空かどうか\r\n *\r\n * @return {bool}\r\n */\r\nfunction isMarkerTableEmpty() {\r\n  return ObjMarkerTable.getDataCount() === 0;\r\n}\r\n\r\n/**\r\n * MarkerTableをクリアする\r\n */\r\nfunction clearMarkerTable() {\r\n  var rows = ObjMarkerTable.getRows();\r\n  rows.forEach(function(row) {\r\n    APP.removeMarker(row.getData().id);\r\n    row.delete();\r\n  });\r\n}\r\n\r\n/**\r\n * MarkerTableをCSVでダウンロードする\r\n */\r\nfunction downloadMarkerTableAsCSV() {\r\n  MarkerTable.download(csvFormatter, 'MarkerTable.csv');\r\n}\r\n\r\n/**\r\n * テーブルカラムのタイトルとフィールドのペアを取得する\r\n *\r\n * @example\r\n * getColumnFieldTitlePairs(ObjMarkerTable)\r\n * {\r\n *   \"Act\": \"act\"\r\n *   \"ID\": \"id\"\r\n *   \"Name\": \"name\"\r\n *   \"Parent ID\": \"parentid\"\r\n *   \"Radius\": \"radius\"\r\n *   \"R\": \"r\"\r\n *   \"G\": \"g\"\r\n *   \"B\": \"b\"\r\n *   \"X\": \"x\"\r\n *   \"Y\": \"y\"\r\n *   \"Z\": \"z\"\r\n * }\r\n */\r\nfunction getColumnFieldTitlePairs(table) {\r\n  var columnDefinitions = table.getColumnDefinitions();\r\n  var fieldTitlePairs = {};\r\n  columnDefinitions.forEach(function(column) {\r\n    fieldTitlePairs[column.title] = column.field;\r\n  });\r\n  return fieldTitlePairs;\r\n}\r\n\r\n/**\r\n * キーがのタイトルのJSONデータをフィールド名にを変換する\r\n * CSVの1行目タイトルは表記用のものでスペースも含まれるため、内部キー名に変換する\r\n *\r\n * @example\r\n * replaceColumnTitle(ObjMarkerTable, {\r\n *   \"Act\": \"1\"\r\n *   \"ID\": \"2\"\r\n *   \"Name\": \"Marker1\"\r\n *   \"Parent ID\": \"3036\"\r\n *   \"Radius\": \"2\"\r\n *   \"R\": \"255\"\r\n *   \"G\": \"0\",\r\n *   ...\r\n * });\r\n *\r\n * // 以下のようになる\r\n * {\r\n *   \"act\": \"1\"\r\n *   \"id\": \"2\"\r\n *   \"name\": \"Marker1\"\r\n *   \"parentid\": \"3036\"\r\n *   \"radius\": \"2\"\r\n *   \"r\": \"255\"\r\n *   \"g\": \"0\",\r\n *   ...\r\n * }\r\n */\r\nfunction replaceColumnTitle(table, json) {\r\n  var fieldTitlePairs = getColumnFieldTitlePairs(table);\r\n  return json.reduce(function(memo, data) {\r\n    var newData = {};\r\n    Object.keys(data).forEach(function(key) {\r\n      var value = data[key];\r\n      var newKey = fieldTitlePairs[key];\r\n      newData[newKey] = value;\r\n    });\r\n    memo.push(newData);\r\n    return memo;\r\n  }, []);\r\n}\r\n\r\n\r\n/**\r\n * renderMarkerに渡されるパラメータが適切な値かチェックする\r\n * CSVファイルから読まれ不正な値の可能性があるので扱える値かどうかを調べる\r\n *\r\n * @param  {Object} markerData renderMarkerの引数と同じ\r\n * @return {bool} すべての値が適切ならtrue,そうじゃないならfalse\r\n */\r\nfunction validateMarkerDataType(markerData) {\r\n  if (!util.isNumeric(markerData.act)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.id)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.parentid)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.radius)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.r)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.g)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.b)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.x)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.y)) {\r\n    return false;\r\n  }\r\n  if (!util.isNumeric(markerData.z)) {\r\n    return false;\r\n  }\r\n  if (!util.isMarkerName(markerData.name)) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * CSVファイルから読み込んだMarkerデータで、表示中のMarkerTableと同じ座標のものがあるかチェックする\r\n *\r\n * @param  {Object} markerData renderMarkerの引数と同じ\r\n * @return {bool} すべての値が適切ならtrue,そうじゃないならfalse\r\n */\r\nfunction validateMarkerDataXYZ(markerData) {\r\n  var rows = ObjMarkerTable.getRows();\r\n  return rows.every(function(row) {\r\n    var rowData = row.getData();\r\n    var rowX = rowData.x;\r\n    var rowY = rowData.y;\r\n    var rowZ = rowData.z;\r\n    var markerDataX = Number(markerData.x);\r\n    var markerDataY = Number(markerData.y);\r\n    var markerDataZ = Number(markerData.z);\r\n\r\n    // 浮動小数点数のため、小数点2桁までで比較する。だいたい同じ座標かどうかチェックする\r\n    if (rowX.toFixed(2) === markerDataX.toFixed(2) &&\r\n        rowY.toFixed(2) === markerDataY.toFixed(2) &&\r\n        rowZ.toFixed(2) === markerDataZ.toFixed(2)) {\r\n      // 同じ座標\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n}\r\n","import { APP } from \"./APP\";\r\nimport { updatePaintObservation, paintManager } from \"./SyncPaint\";\r\nimport { setColorOptions } from \"three-annotator\"\r\nimport * as Tabulator from \"tabulator-tables\";\r\n\r\nconst mutatorClip = (value, data, type, mutatorParams, component) => {\r\n  const min = mutatorParams.min;\r\n  const max = mutatorParams.max;\r\n  return value <= min ? min :\r\n         value >= max ? max :\r\n         value;\r\n}\r\n\r\nconst mutatorParamsClip = {min: 0, max: 255};\r\n\r\n// 0-1までのなるべく離れた値を返す\r\nconst reversalBit = index => {\r\n  let original = index, fraction = 1, value = 0;\r\n  while(original) {\r\n    const bit = original % 2;\r\n    original = (original - bit) / 2;\r\n    fraction /= 2;\r\n    value += bit * fraction;\r\n  }\r\n  return value;\r\n}\r\n\r\n// 彩度が最大で、なるべく異なる色相の色を返す\r\nconst getRandomColor = (index) => {\r\n  const value = ((reversalBit(index - 1)) % 1) * 3;\r\n  const mainColorType = Math.floor(value);\r\n  const subColorValue = Math.floor((value - mainColorType) * 255);\r\n  const colors = [subColorValue, 255 - subColorValue];\r\n  colors.splice(mainColorType, 0, 0);\r\n  return {\r\n    r: colors[0],\r\n    g: colors[1],\r\n    b: colors[2],\r\n  }\r\n}\r\n\r\nexport const updateColorOptionsOnAnnotator = () => {\r\n  updatePaintObservation();\r\n  const activeColors = [];\r\n  const colorParams = {\r\n    eraser: {r: 1, g: 1, b: 1},\r\n  };\r\n  const tableData = PaintTable.getData(\"active\");\r\n  let targetColorId = null;\r\n  for (const row of tableData) {\r\n    colorParams[row.id] = {r: row.r / 255, g: row.g / 255, b: row.b / 255};\r\n    if(row.target) {\r\n      targetColorId = row.id;\r\n    } else if (row.visibility) {\r\n      activeColors.push(row.id);\r\n    }\r\n  }\r\n  if(targetColorId) {\r\n    activeColors.unshift(targetColorId);\r\n  }\r\n\r\n  let colorOptions = {\r\n    activeColors: activeColors,\r\n    colorParams: colorParams,\r\n    eraser: !APP.paint_on,\r\n    overwrite: APP.paint_overwriteB\r\n  }\r\n  setColorOptions(colorOptions, {meshes: APP.getMeshes()});\r\n};\r\n\r\nexport const PaintTable = new Tabulator('#PaintTable', {\r\n\tlayout:\"fitColumns\",\r\n\tautoResize:true,\r\n\tresponsiveLayout:\"hide\",\r\n\ttooltips:true,\r\n\taddRowPos:\"top\",\r\n\thistory:true,\r\n\tpagination:\"local\",\r\n\tpaginationSize:10,\r\n\tresizableRows:true,\r\n\tmovableRows: true,\r\n\tinitialSort:[],\r\n\tcolumns:[\r\n      {title: \"Delete\", formatter: \"buttonCross\",  hozAlign: \"center\", cellClick: (e, cell) => {cell.getRow().delete()}, headerSort:false},\r\n      {title: \"Visible\", field:\"visibility\", width: 73, hozAlign:\"center\", formatter:\"tickCross\", headerSort:false, cellClick: (e, cell)=>{\r\n        const value = cell.getRow().getData();\r\n        cell.setValue(!value.visibility || value.target);\r\n        updateColorOptionsOnAnnotator();\r\n        updateMetricsOnPaintTable();\r\n    }},\r\n      {title: \"Target\", field:\"target\", width: 73, hozAlign:\"center\", formatter:\"tickCross\", headerSort:false, cellClick: (e, cell)=>{\r\n        const table = PaintTable;\r\n        const value = cell.getRow().getData();\r\n        table.setData(table.getData(\"active\").map(item => { \r\n          item = Object.assign({}, item);\r\n          item.debug = true;\r\n          item.target = value.id == item.id;\r\n          item.visibility = item.visibility || item.target;\r\n          return item;  \r\n        }))\r\n        updateColorOptionsOnAnnotator();\r\n      }},\r\n\t    {title: \"ID\", field:\"id\", width: 40, headerSort:false},\r\n\t    {title: \"Name\", field: \"name\", editor: \"input\", headerSort:false, cellEdited: () => updateColor()},\r\n   \t  {title: \"R\", field: \"r\", minWidth: 30, width: 35, hozAlign: \"right\", visible: true, editor: \"number\", editorParams: {min:0, max: 255, step: 1}, mutator: mutatorClip, mutatorParams: mutatorParamsClip, headerSort:false, cellEdited: () => updateColor()},\r\n\t    {title: \"G\", field: \"g\", minWidth: 30, width: 35, hozAlign: \"right\", visible: true, editor: \"number\", editorParams: {min:0, max: 255, step: 1}, mutator: mutatorClip, mutatorParams: mutatorParamsClip, headerSort:false, cellEdited: () => updateColor()},\r\n\t    {title: \"B\", field: \"b\", minWidth: 30, width: 35, hozAlign: \"right\", visible: true, editor: \"number\", editorParams: {min:0, max: 255, step: 1}, mutator: mutatorClip, mutatorParams: mutatorParamsClip, headerSort:false, cellEdited: () => updateColor()},\r\n\t    {title: \"Area\", field: \"area\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}},\r\n\t    {title: \"Volume\", field: \"volume\", headerSort:false, formatter: \"money\", formatterParams: {precision: 5}}\r\n\t],  \r\n  rowMoved: (row) => {\r\n    updateColor();\r\n  },\r\n  rowDeleted: (row) => {\r\n    updateColor();\r\n  },\r\n  rowAdded: (row) => {\r\n    updateColor();\r\n  }\r\n});\r\n\r\n\r\nconst updateColor = () => {\r\n  updateColorOptionsOnAnnotator()\r\n  paintManager.updateList({ list: PaintTable.getData(), lastPaintId })\r\n};\r\n\r\nwindow.switchAnnotation = (checked) => {\r\n\tAPP.paint_mode = checked;\r\n\tAPP.controls.noRotate = checked;\r\n}; \r\n\r\nwindow.switchEraserAnnotation = (checked) => {\r\n\tAPP.paint_on = checked;\r\n  updateColorOptionsOnAnnotator()\r\n};\r\n\r\nwindow.setAnnotationOverwrite = (checked) => {\r\n  APP.paint_overwriteB = checked;\r\n  updateColorOptionsOnAnnotator()\r\n}\r\n\r\nlet lastPaintId = 0;\r\n$('#button-add-paint-layer').on('click', (event) => {\r\n    lastPaintId++;\r\n    const hasTarget = PaintTable.getData(\"active\").some(item => item.target);\r\n    var layer = Object.assign({id: lastPaintId, name: \"Layer\" + String(lastPaintId), area:0, volume: 0, visibility: true, target: !hasTarget}, getRandomColor(lastPaintId));\r\n    PaintTable.addData(layer);\r\n    updateColorOptionsOnAnnotator()\r\n});\r\n\r\n$('#save-paint-table-csv').on('click', (event) => {\r\n  downloadPaintTableAsCSV();\r\n});\r\n\r\n\r\n//// 200907\r\n\r\n$('#calc-volumes').on('click', (event) => {\r\n\tconst call_url   = location.protocol+\"//\"+location.host+\"/ws/paintvolume\";\r\n\tvar req = new XMLHttpRequest();\r\n\treq.open(\"get\", call_url, false);\r\n\treq.send(null);\r\n\tif (req.responseText == \"False\") {\r\n\t\talert(\"No paintvolume.\");\r\n\t\treturn false;\r\n\t\t}\r\n});\r\n////\r\n\r\nconst downloadPaintTableAsCSV = () => {\r\n  const tableData = PaintTable.getData(\"active\");\r\n  const csvData = [[\"id\", \"name\", \"r\", \"g\", \"b\", \"area\", \"volume\"]]\r\n  for (const row of tableData) {\r\n    csvData.push([row.id, row.name, row.r, row.g, row.b, row.area, row.volume]);\r\n  }\r\n\r\n  const csvContent = \"data:text/csv;charset=utf-8,\" +\r\n  csvData.map(e => e.join(\",\")).join(\"\\n\");\r\n  const encodeUri = encodeURI(csvContent);\r\n  // window.open(encodeUri); This also download CSV file\r\n  \r\n  const link = document.createElement(\"a\");\r\n  link.setAttribute(\"href\", encodeUri);\r\n  link.setAttribute(\"download\", \"paint.csv\");\r\n  document.body.appendChild(link);\r\n  link.click();\r\n};\r\n\r\nconst syncSequence = true;\r\n\r\npaintManager.emitter.on(\"update\", data => {\r\n  if(data.room_id === \"list\") {\r\n    const currentRows = PaintTable.getData() || [];\r\n    const incomingRows = data.list || [];\r\n\r\n    console.log(incomingRows);\r\n\r\n\r\n    if(syncSequence) { \r\n      const currentRowsMap = new Map(currentRows.map(currentRow => [currentRow.id, currentRow]));\r\n      PaintTable.setData(incomingRows.map(incomingRow => {\r\n        const currentRow = currentRowsMap.get(incomingRow.id);\r\n        return {\r\n          visibility: true,\r\n          ...currentRow,\r\n          id: incomingRow.id,\r\n          name: incomingRow.name,\r\n          r: incomingRow.r,\r\n          g: incomingRow.g,\r\n          b: incomingRow.b,\r\n        }\r\n      }));\r\n    } else {\r\n      const incomingRowsMap = new Map(incomingRows.map(incomingRow => [incomingRow.id, incomingRow]));\r\n      const newRows = [];\r\n      for(const currentRow of currentRows) {\r\n        if(incomingRowsMap.has(currentRow.id)) {\r\n          const incomingRow = incomingRowsMap.get(currentRow.id);\r\n          newRows.push({\r\n            ...currentRow,\r\n            name: incomingRow.name,\r\n            r: incomingRow.r,\r\n            g: incomingRow.g,\r\n            b: incomingRow.b,\r\n          })\r\n          incomingRowsMap.delete(currentRow.id);\r\n        }\r\n      }\r\n      for(const [id, incomingRow] of incomingRowsMap) {\r\n        newRows.push({\r\n          id: incomingRow.id,\r\n          visibility: true,\r\n          name: incomingRow.name,\r\n          r: incomingRow.r,\r\n          g: incomingRow.g,\r\n          b: incomingRow.b,\r\n        });\r\n      }\r\n      PaintTable.setData(newRows);\r\n    }\r\n    lastPaintId = data.lastPaintId || 0;\r\n    updateColorOptionsOnAnnotator()\r\n  }\r\n})\r\n","import { APP } from \"./APP\";\r\nimport { csvFormatter } from \"./csv\";\r\nimport { updateMetricsOnPaintTable } from \"./HandleBasement\";\r\nimport * as Tabulator from \"tabulator-tables\";\r\n\r\nexport const SurfaceTable = new Tabulator(\"#SurfaceTable\", {\r\n\tajaxURL:\"./surface/segmentInfo.json\",\r\n\tlayout:\"fitColumns\",      //fit columns to width of table\r\n\tautoResize:true,\r\n\tresponsiveLayout:\"hide\",  //hide columns that dont fit on the table\r\n\ttooltips:true,            //show tool tips on cells\r\n\taddRowPos:\"top\",          //when adding a new row, add it to the top of the table\r\n\thistory:true,             //allow undo and redo actions on the table\r\n\tpagination:\"local\",       //paginate the data\r\n\tpaginationSize:10,         //allow 7 rows per page of data\r\n\tresizableRows:true,       //allow row order to be changed\r\n\tinitialSort:[             //set the initial sort order of the data\r\n\t\t{column:\"name\", dir:\"asc\"},\r\n\t],\r\n\tcolumns:[                 //define the table columns\r\n    // ActやConfidenceはダウンロード時に除外されないよう定義しておく。ただしカラムvisible: falseにして非表示にする\r\n    {title:\"Act\", field: \"act\", download: true, visible: false},\r\n\t\t{title:\"Visible\", field:\"act\", width: 73, hozAlign:\"center\",formatter:\"tickCross\", cellClick: (e, cell)=>{cell.setValue(!cell.getValue());}, download: false},\r\n\t\t{title:\"ID\", field:\"id\", width: 50},\r\n\t\t{title:\"Name\", field:\"name\", editor:\"input\"},\r\n\t\t{title:\"Size\", field:\"size\", width:60, hozAlign:\"right\"},\r\n    {title:\"Confidence\", field: \"confidence\", download: true, visible: false},\r\n\t\t{title:\"R\", field:\"r\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\r\n\t\t{title:\"G\", field:\"g\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\r\n\t\t{title:\"B\", field:\"b\", minWidth: 30, width: 35, hozAlign:\"right\", editor:\"range\",editorParams:{min:0, max:255, step:1}},\r\n\t],\r\n\r\n\t// セルが編集されたとき\r\n  cellEdited: function(cell) {\r\n      // 渡ってくるパラメータcellについて: http://tabulator.info/docs/4.1/components#component-cell\r\n      // 編集後の値\r\n      var cellValue = cell.getValue();\r\n      // 編集前の値\r\n      var cellOldValue = cell.getOldValue();\r\n      // 編集対象のセルがある列\r\n      var row = cell.getRow();\r\n      var act = row.getData().act;\r\n      var id  = row.getData().id;\r\n      var r   = row.getData().r;\r\n      var g   = row.getData().g;\r\n      var b   = row.getData().b;\r\n      // 編集したセルに対するカラムのフィールド\r\n      var columnField = cell.getColumn().getField();\r\n      // console.log(\"編集後の値:\", cellValue, \"編集前の値:\", cellOldValue, \"編集した列:\", row, \"編集したカラム\", columnField);\r\n\r\n\r\n\t  var col = r*256*256+g*256+b*1 ;\r\n\t  if(columnField == 'act') {\r\n\t  \tif(act == true) {\r\n\t  \t\tconsole.log(\"Requested ID:\", id );\r\n\t\t\tAPP.addSurfaceObject(id, col);\r\n\t\t\tAPP.addSkeletonObject(id, col);\r\n\t\t\t}\r\n\t  \tif(act == false) {\r\n\t  \t\tconsole.log(\"Disappear ID:\", id )\r\n\t\t\t//const filename = sprintf(\"./stls/i%d.stl\", id );\r\n\t\t\tAPP.removeSurfaceObject(id);\r\n\t\t\tAPP.removeSkeletonObject(id);\r\n\t\t\t}\r\n\t\t\tupdateMetricsOnPaintTable();\r\n\t\t}\r\n\t  if(columnField == 'r' || columnField == 'g' || columnField == 'b') {\r\n\t  \tconsole.log(\"Changecolor ID:\", id )\r\n\t\tAPP.changeSurfaceObjectColor(id, col);\r\n\t\tAPP.changeSkeletonObjectColor(id, col);\r\n\t\t}\r\n    }\r\n\r\n});\r\n\r\n// 「Download CSV」ボタンを押したとき\r\n$('#save-object-table-csv').on('click', function(event) {\r\n  downloadSurfaceTableAsCSV();\r\n  return false;\r\n});\r\n\r\n/**\r\n * ObjectTableをCSVでダウンロードする\r\n */\r\nfunction downloadSurfaceTableAsCSV() {\r\n  console.log(\"downloadObjectTableAsCSV\");\r\n  SurfaceTable.download(csvFormatter, 'SurfaceTable.csv');\r\n}\r\n","import { PaintTable } from \"./PaintTable\";\r\nimport { SurfaceTable } from \"./SurfaceTable\";\r\nimport crypto from \"crypto\";\r\nimport EventEmitter from \"events\";\r\nimport io from \"socket.io-client\";\r\n\r\nexport const socket = io(`${location.origin}/`);\r\nsocket.on('system', data => {\r\n  console.log('system', data);\r\n});\r\n\r\nconst subtract  = function *(a, b) {\r\n  for(const item of a) {\r\n    if(!b.has(item)) {\r\n      yield item;\r\n    }\r\n  }\r\n}\r\n\r\nclass RoomManager {\r\n  values = new Map();\r\n  emitter = new EventEmitter();\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.socket.on('update', this.onUpdateData);\r\n    this.socket.on('current', this.onUpdateData);\r\n  }\r\n  onUpdateData = data => {\r\n    const currentData = this.values.get(data.room_id);\r\n    if(!currentData || (currentData.sid || this.socket.id) !== this.socket.id || data.sid !== this.socket.id) {\r\n      this.values.set(data.room_id, data);\r\n      this.emitter.emit(\"update\", data);\r\n    }\r\n  }\r\n  enterRoom(roomId) {\r\n    this.socket.emit(\"enter\", roomId)  \r\n  }\r\n  leaveRoom(roomId) {\r\n    this.socket.emit(\"leave\", roomId);\r\n    this.values.delete(roomId);\r\n  }\r\n}\r\n\r\nclass PaintManager extends RoomManager{\r\n  colors = new Set();\r\n  surfaces = new Set();\r\n\r\n  getRoomId({surface, color}) {\r\n    return `${surface}-${color}`;\r\n  }\r\n\r\n  addColor(color) {\r\n    for(const surface of this.surfaces) {\r\n      this.enterRoom(this.getRoomId({color, surface}));\r\n    }\r\n    this.colors.add(color);\r\n  }\r\n  removeColor(color) {\r\n    for(const surface of this.surfaces) {\r\n      this.leaveRoom(this.getRoomId({color, surface}));\r\n    }\r\n    this.colors.delete(color);\r\n  }\r\n  addSurface(surface) {\r\n    for(const color of this.colors) {\r\n      this.enterRoom(this.getRoomId({color, surface}));\r\n    }\r\n    this.surfaces.add(surface);\r\n  }\r\n  removeSurface(surface) {\r\n    for(const color of this.colors) {\r\n      this.leaveRoom(this.getRoomId({color, surface}));\r\n    }\r\n    this.surfaces.delete(surface);\r\n  }\r\n  update(data) {\r\n    for(const [objectId, objectData] of Object.entries(data.changes)) {\r\n      for(const [colorId, colorData] of Object.entries(objectData)) {\r\n        const roomId = objectId + \"-\" + colorId;\r\n        this.values.set(roomId, colorData);\r\n      }\r\n    }\r\n    this.socket.emit(\"update_paint\", data)\r\n  }\r\n  updateList({ list, lastPaintId }) {\r\n    this.socket.emit(\"update\", {\r\n      list,\r\n      lastPaintId,\r\n      room_id: \"list\"\r\n    })\r\n  }\r\n}\r\n\r\n\r\nexport const paintManager = new PaintManager(socket);\r\n\r\nlet oldActiveColors = new Set();\r\nexport const updatePaintObservation = () => {\r\n  const activeColors = new Set();\r\n  const tableData = PaintTable.getData(\"active\");\r\n  for (const row of tableData) {\r\n    if (row.visibility) {\r\n      activeColors.add(row.id);\r\n    }\r\n  }\r\n  for(const item of subtract(oldActiveColors, activeColors)) {\r\n    paintManager.removeColor(item);\r\n  }\r\n  for(const item of subtract(activeColors, oldActiveColors)) {\r\n    paintManager.addColor(item);\r\n  } \r\n  oldActiveColors = activeColors;\r\n}\r\n","// TabulatorのcsvFormatterに不具合があるため再定義する\r\n// csvFormatter from Download.prototype.downloaders in tabulator.js\r\nexport const csvFormatter = function(columns, data, options, setFileContents, config) {\r\n  // TabulatorのcsvFormatterは隠れてるカラムがダウンロード対象にならないためカラムを再定義する\r\n  var columnDefinitions = this.table.getColumnDefinitions();\r\n  columns = columnDefinitions.filter(function(column) {\r\n    return column.download !== false;\r\n  });\r\n\r\n  var self = this,\r\n    titles = [],\r\n    fields = [],\r\n    delimiter = options && options.delimiter ? options.delimiter : \",\",\r\n    fileContents;\r\n\r\n  //build column headers\r\n  function parseSimpleTitles() {\r\n    columns.forEach(function (column) {\r\n      titles.push('\"' + String(column.title).split('\"').join('\"\"') + '\"');\r\n      fields.push(column.field);\r\n    });\r\n  }\r\n\r\n  function parseColumnGroup(column, level) {\r\n    if (column.subGroups) {\r\n      column.subGroups.forEach(function (subGroup) {\r\n        parseColumnGroup(subGroup, level + 1);\r\n      });\r\n    } else {\r\n      titles.push('\"' + String(column.title).split('\"').join('\"\"') + '\"');\r\n      fields.push(column.definition.field);\r\n    }\r\n  }\r\n\r\n  if (config.columnGroups) {\r\n    console.warn(\"Download Warning - CSV downloader cannot process column groups\");\r\n    columns.forEach(function (column) {\r\n      parseColumnGroup(column, 0);\r\n    });\r\n  } else {\r\n    parseSimpleTitles();\r\n  }\r\n\r\n  //generate header row\r\n  fileContents = [titles.join(delimiter)];\r\n\r\n  function parseRows({ data }) {\r\n    //generate each row of the table\r\n    data.forEach(function (row) {\r\n      var rowData = [];\r\n\r\n      fields.forEach(function(field) {\r\n        // getFieldValueを使うと数値がfalseになるため単純にrowの値を使う\r\n        //var value = self.getFieldValue(field, row);\r\n        var value = row[field];\r\n\r\n        switch (typeof value) {\r\n          case \"object\":\r\n            value = JSON.stringify(value);\r\n            break;\r\n          case \"undefined\":\r\n          case \"null\":\r\n            value = \"\";\r\n            break;\r\n        }\r\n\r\n        //escape quotation marks\r\n        rowData.push('\"' + String(value).split('\"').join('\"\"') + '\"');\r\n      });\r\n\r\n      fileContents.push(rowData.join(delimiter));\r\n    });\r\n  }\r\n\r\n  function parseGroup(group) {\r\n    if (group.subGroups) {\r\n      group.subGroups.forEach(function (subGroup) {\r\n        parseGroup(subGroup);\r\n      });\r\n    } else {\r\n      parseRows(group.rows);\r\n    }\r\n  }\r\n\r\n  if (config.rowGroups) {\r\n    console.warn(\"Download Warning - CSV downloader cannot process row groups\");\r\n    data.forEach(function (group) {\r\n      parseGroup(group);\r\n    });\r\n  } else {\r\n    parseRows(data);\r\n  }\r\n\r\n  setFileContents(fileContents.join(\"\\n\"), \"text/csv\");\r\n};\r\n\r\n\r\n/**\r\n * カンマ区切りのCSV文字列から配列に変換する\r\n *\r\n * @param  {string} csv カンマ区切りの文字列\r\n * @return {Array}  変換した配列\r\n */\r\nexport function parseCSV(csv) {\r\n  var result = [];\r\n  var array = csv2array(csv);\r\n\r\n  for (var i = 1; i < array.length; i++) {\r\n    result[i - 1] = {};\r\n    for (var k = 0; k < array[0].length && k < array[i].length; k++) {\r\n      var key = array[0][k];\r\n      result[i - 1][key] = array[i][k];\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * カンマ区切りCSVの一行を配列に変換する\r\n *\r\n * 参考: RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files\r\n * https://tools.ietf.org/html/rfc4180\r\n * https://stackoverflow.com/questions/33155999/converting-a-csv-file-into-a-2d-array/33156233\r\n *\r\n * @param  {string} csv カンマ区切りの文字列\r\n * @param  {string} [delimiter=','] 区切り文字。デフォルト=','\r\n * @return {array} カンマ区切りをを変換した配列\r\n */\r\nfunction csv2array(csv, delimiter) {\r\n  delimiter = delimiter || ',';\r\n\r\n  var pattern = new RegExp(\r\n    // [1] delimiter\r\n    '(\\\\' + delimiter + '|\\\\r?\\\\n|\\\\r|^)' +\r\n    '(?:' +\r\n      // [2] quoted value\r\n      '\"([^\"]*(?:\"\"[^\"]*)*)\"|' +\r\n      // [3] standard value\r\n      '([^\"\\\\' + delimiter + '\\\\r\\\\n]*)'+\r\n    ')',\r\n    'gi'\r\n  );\r\n\r\n  var array = [[]];\r\n  var m, matchedDelimiter, matchedValue;\r\n\r\n  while ((m = pattern.exec(csv))) {\r\n    matchedDelimiter = m[1];\r\n    if (matchedDelimiter.length && matchedDelimiter !== delimiter) {\r\n      array.push([]);\r\n    }\r\n\r\n    if (m[2]) {\r\n      matchedValue = m[2].replace(/\"\"/g, '\"');\r\n    } else {\r\n      matchedValue= m[3];\r\n    }\r\n    array[array.length - 1].push(matchedValue);\r\n  }\r\n\r\n  return array;\r\n}\r\n","import \"../js/ControlAnnotator\";\r\nimport \"../js/csv\";\r\nimport \"../js/MarkerTable\";\r\nimport \"../js/util\";\r\nimport \"../js/SurfaceTable\";\r\nimport \"../js/HandleSurfaces\";\r\nimport \"../js/HandleSkeletons\";\r\nimport \"../js/HandleMarkers\";\r\nimport \"../js/SyncPaint\";\r\n\r\nimport { launchAnnotator } from \"../js/HandleBasement\";\r\nlaunchAnnotator();\r\n","var util = {};\r\n\r\n/**\r\n * 有効な数値かどうかチェックする。文字列なら数値として有効かチェックする\r\n *\r\n * @example\r\n * isNumeric(1) // true\r\n * isNumeric(123.456) // true\r\n * isNumeric(0) // true\r\n * isNumeric(-123) // true\r\n * isNumeric(\"abc\") // false\r\n * isNumeric(\"123\") // true\r\n * isNumeric(\"-123\") // true\r\n *\r\n * @param  {string|number} n チェックする対象の値\r\n * @return {boolean}\r\n */\r\nutil.isNumeric = function(n) {\r\n  return !isNaN(parseFloat(n)) && isFinite(n);\r\n};\r\n\r\n/**\r\n * マーカー名として有効かチェック\r\n * 英数字 [a-zA-Z0-9_-] またはスペースで構成される文字列かどうかチェックする\r\n *\r\n * @example\r\n * isMarkerName('abc') // true\r\n * isMarkerName('Marker Test 3') // true\r\n * isMarkerName('マーカー') // false\r\n *\r\n * @param  {string} str チェックする対象の文字列\r\n * @return {boolean}\r\n */\r\nutil.isMarkerName = function(string) {\r\n  return /^(?:[a-zA-Z0-9_-]| )+$/.test(string);\r\n};\r\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;ACDA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAlCA;AAoCA;AAEA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAQA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;;;;;;;;;;;;;AC1YA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAHA;AACA;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;AC5IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3DA;AACA;AA+DA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAKA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;ACzTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhDA;AACA;AAmDA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACpPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAlEA;AACA;AAsEA;AACA;AACA;AACA;AAEA;;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AADA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAtBA;AACA;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAhDA;AACA;AAkDA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAPA;AACA;AACA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAWA;AACA;AAEA;AAEA;AAGA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;ACXA;AAEA;;;;;;;;;;;;;;;;AAeA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAYA;AACA;AACA;;;;;;;;;;;ACnCA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}